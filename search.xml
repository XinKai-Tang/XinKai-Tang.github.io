<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Sarsa＆Q-learning】强化学习入门</title>
      <link href="/2021/07/15/%E3%80%90Sarsa%EF%BC%86Q-learning%E3%80%91%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
      <url>/2021/07/15/%E3%80%90Sarsa%EF%BC%86Q-learning%E3%80%91%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1>问题导入</h1><p>分别使用Sarsa算法、Q-learning算法解决悬崖问题，需要提前安装<code>gym</code>库</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br></pre></td></tr></table></figure><hr/><h1>一、强化学习</h1><h2 id="1-核心思想">1. 核心思想</h2><p>强化学习（Reinforcement Learning）通过不断的试错探索，吸取经验和教训，持续不断的优化策略，以便从环境中拿到更好的反馈，不断提升模型的正确决策的能力。<br><img src="https://img-blog.csdnimg.cn/400e77f8a3e541439ab955fa845911e0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS2V2aW4gIFRhbmc=,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center" alt=""><br>智能体<code>agent</code>在训练环境<code>environment</code>中学习，根据环境的全局状态<code>state</code>或观测到的局部观测值<code>observation</code>，执行相应的动作<code>action</code>，并根据环境的反馈<code>reward</code>来指导更好的动作。</p><h2 id="2-算法分类">2. 算法分类</h2><p>（1）按照环境是否已知可以分为<code>Model-Based</code>和<code>Model-Free</code>。<br>比较常用的是后者，因为大多数情况下，智能体所处的环境是未知的。</p><p>（2）按照应用环境可以分为<code>基于离散控制场景的强化学习算法</code>和<code>基于连续控制场景的强化学习算法</code>。<br>前者常见的有：DQN算法、DDQN算法等，后者常见的有DDPG算法、TD3算法、Policy Gradient算法等。</p><p>（3）按照学习方式可以分为<code>On-Policy</code>和<code>Off-Policy</code>。<br>Sarsa算法就属于On-Policy算法，Q-learning算法就属于Off-Policy算法。</p><p>（4）按照学习目标可以分为<code>Value-Based</code>和<code>Policy-Based</code>。<br><img src="https://img-blog.csdnimg.cn/d2021f623457439597d74a4d22043abd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS2V2aW4gIFRhbmc=,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt=""></p><hr/><h1>二. Sarsa算法</h1><h2 id="1-算法简介">1. 算法简介</h2><ul><li><p><code>Sarsa</code>全称是<code>state-action-reward-state'-action'</code>，目的是学习特定的<code>state</code>下，特定<code>action</code>的价值Q，最终建立和优化一个Q表格，以<code>state</code>为行，<code>action</code>为列，根据与环境交互得到的<code>reward</code>来更新Q表格，更新公式为：<br><img src="https://img-blog.csdnimg.cn/img_convert/2ffeab4daf2b0dea32b1e8dd987e0c97.png" alt=""></p></li><li><p>Sarsa在训练中为了更好的探索环境，采用<code>ε-greedy</code>方式来训练，有一定概率随机选择动作输出。</p></li></ul><h2 id="2-算法实现">2. 算法实现</h2><ul><li><strong>构建Agent</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SarsaAgent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obs_dim, act_dim, learning_rate=<span class="number">0.01</span>,</span></span><br><span class="line"><span class="params">                 gamma=<span class="number">0.9</span>, e_greed=<span class="number">0.1</span></span>):</span><br><span class="line">        self.act_dim = act_dim          <span class="comment"># 动作维度，即可选动作数</span></span><br><span class="line">        self.lr = learning_rate     <span class="comment"># 学习率</span></span><br><span class="line">        self.gamma = gamma          <span class="comment"># reward衰减率</span></span><br><span class="line">        self.epsilon = e_greed      <span class="comment"># 随机选取动作的概率</span></span><br><span class="line">        self.Q = np.zeros((obs_dim, act_dim))   <span class="comment"># Q表格</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 依据输入的状态，采样输出的动作值，包含探索</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sample</span>(<span class="params">self, obs</span>):</span><br><span class="line">        <span class="keyword">if</span> np.random.uniform(<span class="number">0</span>, <span class="number">1</span>) &lt; self.epsilon:</span><br><span class="line">            <span class="keyword">return</span> np.random.choice(self.act_dim)     <span class="comment"># 随机探索选取动作</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 根据table的Q值选动作</span></span><br><span class="line">            <span class="keyword">return</span> self.predict(obs)                <span class="comment"># 根据表格的Q值选动作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 依据输入的观察值，预测输出的动作值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, obs</span>):</span><br><span class="line">        Q_list = self.Q[obs, :]</span><br><span class="line">        maxQ = np.<span class="built_in">max</span>(Q_list)</span><br><span class="line">        act_list = np.where(Q_list == maxQ)[<span class="number">0</span>]  <span class="comment"># 找出最大Q值对应的动作</span></span><br><span class="line">        <span class="keyword">return</span> np.random.choice(act_list)       <span class="comment"># 随机选取一个动作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新Q-Table的学习方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">learn</span>(<span class="params">self, obs, action, reward, next_obs, next_act, done</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;【On-Policy】</span></span><br><span class="line"><span class="string">            obs：交互前的状态，即s[t]；</span></span><br><span class="line"><span class="string">            action：本次交互选择的动作，即a[t]；</span></span><br><span class="line"><span class="string">            reward：本次动作获得的奖励，即r；</span></span><br><span class="line"><span class="string">            next_obs：本次交互后的状态，即s[t+1]；</span></span><br><span class="line"><span class="string">            next_act：根据当前Q表格，针对next_obs会选择的动作，即a[t+1]；</span></span><br><span class="line"><span class="string">            done：episode是否结束；</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        current_Q = self.Q[obs, action]     <span class="comment"># 当前的Q值</span></span><br><span class="line">        <span class="keyword">if</span> done:    <span class="comment"># 如果没有下一个状态了，即当前episode已结束</span></span><br><span class="line">            target_Q = reward       <span class="comment"># 目标值就是本次动作的奖励值</span></span><br><span class="line">        <span class="keyword">else</span>:       <span class="comment"># 否则采用SARSA的公式获取目标值</span></span><br><span class="line">            target_Q = reward + self.gamma * self.Q[next_obs, next_act]</span><br><span class="line">        self.Q[obs, action] += self.lr * (target_Q - current_Q)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存Q表格的数据到文件</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>):</span><br><span class="line">        npy_file = <span class="string">&quot;./sarsa.npy&quot;</span></span><br><span class="line">        np.save(npy_file, self.Q)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[1;32m Save data into file: `%s`. \033[0m&quot;</span> % npy_file)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从文件中读取数据到Q表格</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restore</span>(<span class="params">self, npy_file=<span class="string">&#x27;./sarsa.npy&#x27;</span></span>):</span><br><span class="line">        self.Q = np.load(npy_file)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[1;33m Load data from file: `%s`. \033[0m&quot;</span> % npy_file)</span><br></pre></td></tr></table></figure><ul><li><strong>训练&amp;&amp;测试</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run_episode()是agent在一个episode中训练学习的函数，</span></span><br><span class="line"><span class="comment"># 它使用agent.sample()与环境交互，使用agent.learn()训练Q表格</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_episode</span>(<span class="params">env, agent, render=<span class="literal">False</span></span>):</span><br><span class="line">    done, total_steps, total_reward = <span class="literal">False</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    obs = env.reset()           <span class="comment"># 重置环境，开始新的episode</span></span><br><span class="line">    action = agent.sample(obs)  <span class="comment"># 根据状态选择动作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">        next_obs, reward, done, _ = env.step(action)    <span class="comment"># 与环境进行一个交互</span></span><br><span class="line">        next_act = agent.sample(next_obs)               <span class="comment"># 根据状态选取动作</span></span><br><span class="line">        agent.learn(obs, action, reward, next_obs, next_act, done)  <span class="comment"># 学习</span></span><br><span class="line"></span><br><span class="line">        obs, action = next_obs, next_act    <span class="comment"># 记录新的状态和动作</span></span><br><span class="line">        total_reward += reward</span><br><span class="line">        total_steps += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> render:      <span class="comment"># 如果需要渲染一帧图形</span></span><br><span class="line">            env.render()</span><br><span class="line">    <span class="keyword">return</span> total_reward, total_steps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_episode()是agent在一个episode中测试效果的函数，</span></span><br><span class="line"><span class="comment"># 需要评估agent能在一个episode中拿到多少奖励total_reward</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_episode</span>(<span class="params">env, agent, render=<span class="literal">False</span></span>):</span><br><span class="line">    agent.restore()     <span class="comment"># 读取训练好的模型参数</span></span><br><span class="line">    done, total_reward = <span class="literal">False</span>, <span class="number">0</span></span><br><span class="line">    obs = env.reset()   <span class="comment"># 重置环境，开始新的episode</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">        action = agent.predict(obs)                     <span class="comment"># 根据状态预测动作</span></span><br><span class="line">        next_obs, reward, done, _ = env.step(action)    <span class="comment"># 与环境进行一个交互</span></span><br><span class="line">        total_reward += reward</span><br><span class="line">        obs = next_obs</span><br><span class="line">        <span class="keyword">if</span> render:      <span class="comment"># 如果需要渲染一帧图形</span></span><br><span class="line">            env.render()</span><br><span class="line">    <span class="keyword">return</span> total_reward</span><br></pre></td></tr></table></figure><ul><li><strong>启动训练并保存模型</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">env = gym.make(<span class="string">&quot;CliffWalking-v0&quot;</span>)   <span class="comment"># 创建悬崖环境</span></span><br><span class="line"></span><br><span class="line">agent = SarsaAgent(</span><br><span class="line">    env.observation_space.n,        <span class="comment"># 状态的数量</span></span><br><span class="line">    env.action_space.n,             <span class="comment"># 动作的种类数</span></span><br><span class="line">    learning_rate=<span class="number">0.1</span>,              <span class="comment"># 学习率</span></span><br><span class="line">    gamma=<span class="number">0.9</span>,                      <span class="comment"># 奖励衰减率</span></span><br><span class="line">    e_greed=<span class="number">0.1</span>                     <span class="comment"># 随机选取动作的概率</span></span><br><span class="line">)   <span class="comment"># 创建Sarsa智能体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">501</span>):  <span class="comment"># 训练501个episode</span></span><br><span class="line">    <span class="comment"># is_render = episode % 20 == 0   # 是否渲染图像</span></span><br><span class="line">    <span class="comment"># ep_reward, ep_steps = run_episode(env, agent, is_render)</span></span><br><span class="line">    ep_reward, ep_steps = run_episode(env, agent, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">if</span> episode % <span class="number">50</span> == <span class="number">0</span>:   <span class="comment"># 每50个episode输出一次分数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Episode: %3d; Steps: %3d; Reward: %.1f&quot;</span> %</span><br><span class="line">                (episode, ep_steps, ep_reward))</span><br><span class="line"></span><br><span class="line">agent.save()    <span class="comment"># 保存模型参数（Q表格）</span></span><br><span class="line">test_reward = test_episode(env, agent, <span class="literal">False</span>)  <span class="comment"># 测试模型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;【Eval】\t Reward: %.1f&quot;</span> % test_reward)</span><br></pre></td></tr></table></figure><p>实验结果如下（Reward值越大，说明学习效果越好）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Episode:   0; Steps: 857; Reward: -2144.0</span><br><span class="line">Episode:  50; Steps:  33; Reward: -33.0</span><br><span class="line">Episode: 100; Steps:  30; Reward: -129.0</span><br><span class="line">Episode: 150; Steps:  44; Reward: -44.0</span><br><span class="line">Episode: 200; Steps:  15; Reward: -15.0</span><br><span class="line">Episode: 250; Steps:  19; Reward: -118.0</span><br><span class="line">Episode: 300; Steps:  26; Reward: -125.0</span><br><span class="line">Episode: 350; Steps:  19; Reward: -19.0</span><br><span class="line">Episode: 400; Steps:  17; Reward: -17.0</span><br><span class="line">Episode: 450; Steps:  22; Reward: -22.0</span><br><span class="line">Episode: 500; Steps:  19; Reward: -19.0</span><br><span class="line"></span><br><span class="line">【Eval】  Reward: -15.0</span><br></pre></td></tr></table></figure><hr/><h1>三. Q-learning算法</h1><h2 id="1-算法简介-2">1. 算法简介</h2><ul><li><p><code>Q-learning</code>也是采用Q表格的方式存储Q值（状态动作价值），决策部分与Sarsa是一样的，采用ε-greedy方式增加探索。</p></li><li><p><code>Q-learning</code>跟<code>Sarsa</code>不一样的地方是更新Q表格的方式。</p></li></ul><blockquote><ul><li>Sarsa是on-policy的更新方式，先做出动作再更新。</li><li>Q-learning是off-policy的更新方式，更新learn()时无需获取下一步实际做出的动作next_action，并假设下一步动作是取最大Q值的动作。</li></ul></blockquote><ul><li>Q-learning的更新公式为：<br><img src="https://img-blog.csdnimg.cn/img_convert/24e2bcce50ade8fa620ba5d24c5bb4e9.png" alt=""></li></ul><h2 id="2-算法实现-2">2. 算法实现</h2><ul><li><strong>构建Agent</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QLearningAgent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obs_dim, act_dim, learning_rate=<span class="number">0.01</span>,</span></span><br><span class="line"><span class="params">                 gamma=<span class="number">0.9</span>, e_greed=<span class="number">0.1</span></span>):</span><br><span class="line">        self.act_dim = act_dim      <span class="comment"># 动作维度，即可选动作数</span></span><br><span class="line">        self.lr = learning_rate     <span class="comment"># 学习率</span></span><br><span class="line">        self.gamma = gamma          <span class="comment"># reward衰减率</span></span><br><span class="line">        self.epsilon = e_greed      <span class="comment"># 随机选取动作的概率</span></span><br><span class="line">        self.Q = np.zeros((obs_dim, act_dim))   <span class="comment"># Q表格</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 依据输入的状态，采样输出的动作值，包含探索</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sample</span>(<span class="params">self, obs</span>):</span><br><span class="line">        <span class="keyword">if</span> np.random.uniform(<span class="number">0</span>, <span class="number">1</span>) &lt; self.epsilon:</span><br><span class="line">            <span class="keyword">return</span> np.random.choice(self.act_dim)   <span class="comment"># 随机探索选取动作</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 根据table的Q值选动作</span></span><br><span class="line">            <span class="keyword">return</span> self.predict(obs)                <span class="comment"># 根据表格的Q值选动作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 依据输入的观察值，预测输出的动作值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, obs</span>):</span><br><span class="line">        Q_list = self.Q[obs, :]</span><br><span class="line">        maxQ = np.<span class="built_in">max</span>(Q_list)</span><br><span class="line">        act_list = np.where(Q_list == maxQ)[<span class="number">0</span>]  <span class="comment"># 找出最大Q值对应的动作</span></span><br><span class="line">        <span class="keyword">return</span> np.random.choice(act_list)       <span class="comment"># 随机选取一个动作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新Q-Table的学习方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">learn</span>(<span class="params">self, obs, action, reward, next_obs, done</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;【Off-Policy】</span></span><br><span class="line"><span class="string">            obs：交互前的状态，即s[t]；</span></span><br><span class="line"><span class="string">            action：本次交互选择的动作，即a[t]；</span></span><br><span class="line"><span class="string">            reward：本次动作获得的奖励，即r；</span></span><br><span class="line"><span class="string">            next_obs：本次交互后的状态，即s[t+1]；</span></span><br><span class="line"><span class="string">            done：episode是否结束；</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        cur_Q = self.Q[obs, action]</span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            target_Q = reward</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            target_Q = reward + self.gamma * np.<span class="built_in">max</span>(self.Q[next_obs, :])</span><br><span class="line">        self.Q[obs, action] += self.lr * (target_Q - cur_Q)     <span class="comment"># 更新表格</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存Q表格的数据到文件</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>):</span><br><span class="line">        npy_file = <span class="string">&quot;./q_learning.npy&quot;</span></span><br><span class="line">        np.save(npy_file, self.Q)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[1;32m Save data into file: `%s`. \033[0m&quot;</span> % npy_file)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从文件中读取数据到Q表格</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restore</span>(<span class="params">self, npy_file=<span class="string">&#x27;./q_learning.npy&#x27;</span></span>):</span><br><span class="line">        self.Q = np.load(npy_file)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[1;33m Load data from file: `%s`. \033[0m&quot;</span> % npy_file)</span><br></pre></td></tr></table></figure><ul><li><strong>训练&amp;测试</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run_episode()是agent在一个episode中训练学习的函数，</span></span><br><span class="line"><span class="comment"># 它使用agent.sample()与环境交互，使用agent.learn()训练Q表格</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_episode</span>(<span class="params">env, agent, render=<span class="literal">False</span></span>):</span><br><span class="line">    done, total_steps, total_reward = <span class="literal">False</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    obs = env.reset()   <span class="comment"># 重开一局，重置环境</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">        action = agent.sample(obs)                      <span class="comment"># 根据状态选择动作</span></span><br><span class="line">        next_obs, reward, done, _ = env.step(action)    <span class="comment"># 与环境进行一次交互</span></span><br><span class="line">        agent.learn(obs, action, reward, next_obs, done)    <span class="comment"># 学习</span></span><br><span class="line"></span><br><span class="line">        obs = next_obs              <span class="comment"># 记录新的状态</span></span><br><span class="line">        total_reward += reward</span><br><span class="line">        total_steps += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> render:      <span class="comment"># 如果需要渲染一帧图形</span></span><br><span class="line">            env.render()</span><br><span class="line">    <span class="keyword">return</span> total_reward, total_steps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_episode()是agent在一个episode中测试效果的函数，</span></span><br><span class="line"><span class="comment"># 需要评估agent能在一个episode中拿到多少奖励total_reward</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_episode</span>(<span class="params">env, agent, render=<span class="literal">False</span></span>):</span><br><span class="line">    agent.restore()     <span class="comment"># 读取训练好的模型参数</span></span><br><span class="line">    done, total_reward = <span class="literal">False</span>, <span class="number">0</span></span><br><span class="line">    obs = env.reset()   <span class="comment"># 重开一局，重置环境</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">        action = agent.predict(obs)                     <span class="comment"># 根据状态选取动作</span></span><br><span class="line">        next_obs, reward, done, _ = env.step(action)    <span class="comment"># 与环境进行一次交互</span></span><br><span class="line">        total_reward += reward</span><br><span class="line">        obs = next_obs              <span class="comment"># 记录新的状态</span></span><br><span class="line">        <span class="keyword">if</span> render:</span><br><span class="line">            env.render()</span><br><span class="line">    <span class="keyword">return</span> total_reward</span><br></pre></td></tr></table></figure><ul><li><strong>启动训练并保存模型</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">env = gym.make(<span class="string">&quot;CliffWalking-v0&quot;</span>)   <span class="comment"># 创建悬崖环境</span></span><br><span class="line"></span><br><span class="line">agent = QLearningAgent(</span><br><span class="line">    env.observation_space.n,        <span class="comment"># 状态维度</span></span><br><span class="line">    env.action_space.n,             <span class="comment"># 动作维度</span></span><br><span class="line">    learning_rate=<span class="number">0.1</span>,              <span class="comment"># 学习率</span></span><br><span class="line">    gamma=<span class="number">0.9</span>,                      <span class="comment"># reward衰减率</span></span><br><span class="line">    e_greed=<span class="number">0.1</span>                     <span class="comment"># 随机选取动作的概率</span></span><br><span class="line">)   <span class="comment"># 创建Q-learning智能体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">501</span>):  <span class="comment"># 训练501个episode</span></span><br><span class="line">    <span class="comment"># is_render = episode % 20 == 0   # 是否渲染图像</span></span><br><span class="line">    <span class="comment"># ep_reward, ep_steps = run_episode(env, agent, is_render)</span></span><br><span class="line">    ep_reward, ep_steps = run_episode(env, agent, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">if</span> episode % <span class="number">50</span> == <span class="number">0</span>:   <span class="comment"># 每50个episode输出一次分数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Episode: %3d; Steps: %3d; Reward: %.1f&quot;</span> %</span><br><span class="line">                (episode, ep_steps, ep_reward))</span><br><span class="line"></span><br><span class="line">agent.save()    <span class="comment"># 保存模型参数（Q表格）</span></span><br><span class="line">test_reward = test_episode(env, agent, <span class="literal">True</span>)  <span class="comment"># 测试模型</span></span><br><span class="line">sode输出一次分数</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Episode: %3d; Steps: %3d; Reward: %.1f&quot;</span> %</span><br><span class="line">                (episode, ep_steps, ep_reward))</span><br><span class="line"></span><br><span class="line">agent.save()    <span class="comment"># 保存模型参数（Q表格）</span></span><br><span class="line">test_reward = test_episode(env, agent, <span class="literal">False</span>)  <span class="comment"># 测试模型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;【Eval】\t Reward: %.1f&quot;</span> % test_reward)</span><br></pre></td></tr></table></figure><p>实验结果如下（Reward值越大，说明学习效果越好）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Episode:   0; Steps: 519; Reward: -1608.0</span><br><span class="line">Episode:  50; Steps:  20; Reward: -20.0</span><br><span class="line">Episode: 100; Steps:  21; Reward: -21.0</span><br><span class="line">Episode: 150; Steps:  47; Reward: -146.0</span><br><span class="line">Episode: 200; Steps:  18; Reward: -18.0</span><br><span class="line">Episode: 250; Steps:  30; Reward: -228.0</span><br><span class="line">Episode: 300; Steps:  20; Reward: -20.0</span><br><span class="line">Episode: 350; Steps:  13; Reward: -13.0</span><br><span class="line">Episode: 400; Steps:  17; Reward: -17.0</span><br><span class="line">Episode: 450; Steps:  14; Reward: -14.0</span><br><span class="line">Episode: 500; Steps:  50; Reward: -248.0</span><br><span class="line">   </span><br><span class="line">【Eval】  Reward: -13.0</span><br></pre></td></tr></table></figure><hr/><blockquote><h1>写在最后</h1><ul><li>如果您发现项目存在问题，或者如果您有更好的建议，欢迎在下方评论区中留言讨论~</li><li>这是本项目的链接：<a href="https://aistudio.baidu.com/aistudio/projectdetail/2250312?shared=1">实验项目 - AI Studio</a>，点击<code>fork</code>可直接在AI Studio运行~</li><li>这是我的个人主页：<a href="https://aistudio.baidu.com/aistudio/personalcenter/thirdview/118633">个人主页 - AI Studio</a>，来AI Studio互粉吧，等你哦~</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【VGG16】口罩人脸分类</title>
      <link href="/2021/03/20/%E3%80%90VGG16%E3%80%91%E5%8F%A3%E7%BD%A9%E4%BA%BA%E8%84%B8%E5%88%86%E7%B1%BB/"/>
      <url>/2021/03/20/%E3%80%90VGG16%E3%80%91%E5%8F%A3%E7%BD%A9%E4%BA%BA%E8%84%B8%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1>问题导入</h1><p>新冠肺炎病毒在全球肆虐，武汉大学率先公开了口罩遮挡人脸数据集。我们从中选取了6000余张戴口罩的人脸图片和6000余张正常的人脸图片作为实验数据集，以训练改进版的VGG16模型，使其能够实现对人脸是否佩戴口罩的判定。</p><hr/><h1>一、VGG模型</h1><ul><li>VGG 是由 Simonyan 和 Zisserman 在论文 “<a href="https://arxiv.org/abs/1409.1556">Very Deep Convolutional Networks for Large Scale Image Recognition</a>” 中提出卷积神经网络模型，其名称来源于作者所在的牛津大学视觉几何组 (Visual Geometry Group) 的缩写。</li><li>VGG 中根据卷积核大小和卷积层数目的不同，可分为 A、A-LRN、B、C、D、E 共6个配置 (ConvNet Configuration)，其中以 D 和 E 两种配置较为常用，分别称为 VGG16 和 VGG19。本实验使用的是VGG16模型（模型结构如下图 type D 所示）。<br><img src="https://img-blog.csdnimg.cn/img_convert/62b9772f507d42b9d9170eecd7f32735.png#pic_center" alt=""></li></ul><hr/><h1>二、数据集简介</h1><p>本次实验采用的是武汉大学口罩遮挡人脸数据集（RMFD）的一部分，它包含6000余张戴口罩的人脸图片和6000余张正常的人脸图片。<br><img src="https://img-blog.csdnimg.cn/img_convert/922d2a7a7e08387e6f76d2c693aeccee.png#pic_center" alt=""></p><blockquote><p>这是数据集的下载链接：<a href="https://aistudio.baidu.com/aistudio/datasetdetail/52391">人脸口罩分类数据集 - AI Studio</a></p></blockquote><hr/><h1>三、实验步骤</h1><p><img src="https://img-blog.csdnimg.cn/20210208110405937.png#pic_center" alt=""></p><h2 id="0-导入模块-7">0. 导入模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageEnhance</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> cpu_count</span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">from</span> paddle <span class="keyword">import</span> fluid</span><br><span class="line"><span class="keyword">from</span> paddle.utils.plot <span class="keyword">import</span> Ploter       <span class="comment"># paddle 1.8 动态绘图</span></span><br><span class="line"><span class="keyword">from</span> paddle.fluid.dygraph <span class="keyword">import</span> Conv2D, Pool2D, Linear, Dropout</span><br></pre></td></tr></table></figure><h2 id="1-数据准备-5">1. 数据准备</h2><ul><li><strong>数据增强</strong><br>由于实验模型较为复杂，直接训练容易发生过拟合，故在处理实验数据集时采用数据增强的方法扩充数据集的多样性。本实验中用到的数据增强方法有：随机改变亮度，随机改变对比度，随机改变饱和度，随机改变清晰度，随机旋转图像，随机加高斯噪声等。</li></ul><blockquote><p>数据増广（Data Augmentation），即数据增强，数据增强的目的主要是减少网络的过拟合现象，通过对训练图片进行变换可以得到泛化能力更强的网络，更好地适应应用场景。<br>关于数据增强，可参考：<a href="https://aistudio.baidu.com/aistudio/projectdetail/408059">训练数据太少？过拟合？一文带你领略“数据增长魔法”(上)</a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">random_brightness</span>(<span class="params">img, low=<span class="number">0.5</span>, high=<span class="number">1.5</span></span>):  <span class="comment"># 随机改变亮度(0.5~1.5)</span></span><br><span class="line">    x = random.uniform(low, high)</span><br><span class="line">    <span class="keyword">return</span> ImageEnhance.Brightness(img).enhance(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_contrast</span>(<span class="params">img, low=<span class="number">0.5</span>, high=<span class="number">1.5</span></span>):    <span class="comment"># 随机改变对比度(0.5~1.5)</span></span><br><span class="line">    x = random.uniform(low, high)</span><br><span class="line">    <span class="keyword">return</span> ImageEnhance.Contrast(img).enhance(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_color</span>(<span class="params">img, low=<span class="number">0.5</span>, high=<span class="number">1.5</span></span>):       <span class="comment"># 随机改变饱和度(0.5~1.5)</span></span><br><span class="line">    x = random.uniform(low, high)</span><br><span class="line">    <span class="keyword">return</span> ImageEnhance.Color(img).enhance(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_sharpness</span>(<span class="params">img, low=<span class="number">0.5</span>, high=<span class="number">1.5</span></span>):   <span class="comment"># 随机改变清晰度(0.5~1.5)</span></span><br><span class="line">    x = random.uniform(low, high)</span><br><span class="line">    <span class="keyword">return</span> ImageEnhance.Sharpness(img).enhance(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_rotate</span>(<span class="params">img, low=<span class="number">60</span>, high=<span class="number">300</span></span>):       <span class="comment"># 随机旋转图像(-60~60)</span></span><br><span class="line">    temp = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, low)) + <span class="built_in">list</span>(<span class="built_in">range</span>(high, <span class="number">360</span>))</span><br><span class="line">    angle = random.choice(temp)</span><br><span class="line">    <span class="keyword">return</span> img.rotate(angle)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_noise</span>(<span class="params">img, low=<span class="number">0</span>, high=<span class="number">10</span></span>):          <span class="comment"># 随机加高斯噪声(0-10)</span></span><br><span class="line">    img = np.asarray(img)</span><br><span class="line">    sigma = np.random.uniform(low, high)</span><br><span class="line">    noise = np.<span class="built_in">round</span>(np.random.randn(img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>], <span class="number">3</span>) * sigma).astype(<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line">    img = img + noise</span><br><span class="line">    img[img &gt; <span class="number">255</span>] = <span class="number">255</span></span><br><span class="line">    img[img &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> Image.fromarray(img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image_augment</span>(<span class="params">img</span>):          <span class="comment"># 混合叠加上述几种数据增强方法</span></span><br><span class="line">    opts = [random_brightness, random_contrast, random_color,</span><br><span class="line">            random_sharpness, random_rotate, random_noise]</span><br><span class="line">    num = random.randint(<span class="number">0</span>, <span class="number">2</span>)   <span class="comment"># 处理函数的叠加次数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        no = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(opts)-<span class="number">1</span>)</span><br><span class="line">        img = opts[no](img)      <span class="comment"># 处理图片</span></span><br><span class="line">        <span class="keyword">del</span> opts[no]             <span class="comment"># 避免重复叠加相同的操作</span></span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure><ul><li><strong>数据预处理</strong><br>（1）由于数据集中的数据是以压缩包的形式存放的，因此我们需要先解压数据压缩包。<br>（2）接着，我们需要按1:9的比例划分测试集和训练集，分别生成包含数据地址的两个列表。<br>（3）然后，我们需要分别构建用于训练和测试的数据提供器，其中训练数据提供器是乱序、按批次提供数据的。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unzip_data</span>(<span class="params">target_path, path1, path2</span>):   <span class="comment"># 将原数据集解压至指定路径</span></span><br><span class="line">    SRC_PATH = <span class="string">&quot;Masked_Face.zip&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(path1) <span class="keyword">or</span> <span class="keyword">not</span> os.path.isdir(path2):</span><br><span class="line">        z = zipfile.ZipFile(SRC_PATH, <span class="string">&quot;r&quot;</span>)   <span class="comment"># 打开压缩文件，创建zip对象</span></span><br><span class="line">        z.extractall(path=target_path)       <span class="comment"># 解压zip文件至target_path</span></span><br><span class="line">        z.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数据集解压完成！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data_list</span>(<span class="params">lab_no, path</span>):   <span class="comment"># 划分path路径下的数据集</span></span><br><span class="line">    count = <span class="number">0</span>      <span class="comment"># 记录图片的数量</span></span><br><span class="line">    temp_train_list, temp_test_list = [], []   <span class="comment"># 临时存放数据集位置及类别</span></span><br><span class="line">    file_folders = os.listdir(path)            <span class="comment"># 获取path路径下所有的文件夹</span></span><br><span class="line">    <span class="keyword">for</span> folder <span class="keyword">in</span> file_folders:</span><br><span class="line">        images = os.listdir(os.path.join(path, folder))</span><br><span class="line">        <span class="keyword">for</span> img <span class="keyword">in</span> images:</span><br><span class="line">            img_path = os.path.join(path, folder, img)</span><br><span class="line">            value = [img_path, lab_no]    <span class="comment"># 记录图片路径及其标签代号</span></span><br><span class="line">            <span class="keyword">if</span> count % <span class="number">10</span> == <span class="number">0</span>:           <span class="comment"># 按照1:9的比例划分数据集</span></span><br><span class="line">                temp_test_list.append(value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp_train_list.append(value)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> temp_train_list, temp_test_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_reader</span>(<span class="params">data_list, for_test=<span class="literal">False</span></span>):   <span class="comment"># 按批量读取图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_image</span>(<span class="params">img_path</span>):   <span class="comment"># 对图片进行增强处理</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_path).convert(<span class="string">&quot;RGB&quot;</span>)       <span class="comment"># 以RGB模式打开图片</span></span><br><span class="line">        img = img.resize((<span class="number">224</span>, <span class="number">224</span>), Image.ANTIALIAS)   <span class="comment"># 抗锯齿模式缩放图像</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> for_test:  <span class="comment"># 如果处理的是训练集，那么进行增强处理</span></span><br><span class="line">            <span class="keyword">return</span> image_augment(img)</span><br><span class="line">        <span class="keyword">return</span> img        <span class="comment"># 如果处理的是测试集，那么直接返回图片</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">data_mapper</span>(<span class="params">sample</span>):   <span class="comment"># 读取图片并对图片进行归一化处理</span></span><br><span class="line">        img_path, label = sample</span><br><span class="line">        img = process_image(img_path)   <span class="comment"># 对图片进行增强处理</span></span><br><span class="line">        <span class="comment"># 把图像变成一个numpy数组以匹配数据馈送格式：</span></span><br><span class="line">        img = np.array(img).astype(<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">        <span class="comment"># 将图像矩阵由“rgb,rgb,rbg...”转置为“rr...,gg...,bb...”：</span></span><br><span class="line">        img = img.transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        img = img / <span class="number">255.0</span>           <span class="comment"># 将图像数据归一化</span></span><br><span class="line">        <span class="keyword">return</span> img, label </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reader</span>():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> data_list:</span><br><span class="line">            img_path, label = data[<span class="number">0</span>], data[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">yield</span> img_path, <span class="built_in">int</span>(label)  <span class="comment"># 返回图像地址和标签（for循环结束前程序不会停止）</span></span><br><span class="line">    <span class="keyword">return</span> paddle.reader.xmap_readers(data_mapper, reader, cpu_count(), <span class="number">512</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------ 1.1.解压数据集 ------</span></span><br><span class="line">data_path = <span class="string">&quot;./data/&quot;</span>                                   <span class="comment"># 数据集路径</span></span><br><span class="line">normal_path = data_path + <span class="string">&quot;/AFDB_face_dataset&quot;</span>          <span class="comment"># 正常人脸数据集地址</span></span><br><span class="line">masked_path = data_path + <span class="string">&quot;/AFDB_masked_face_dataset&quot;</span>   <span class="comment"># 戴口罩的人脸数据集地址</span></span><br><span class="line">unzip_data(data_path, normal_path, masked_path)         <span class="comment"># 解压原数据集至指定路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 1.2.划分数据集 ------</span></span><br><span class="line"><span class="comment"># lab_dict记录了标签和数字代号的关系：</span></span><br><span class="line">lab_dict = &#123;<span class="string">&quot;0&quot;</span>: <span class="string">&quot;没戴口罩&quot;</span>, <span class="string">&quot;1&quot;</span>: <span class="string">&quot;戴了口罩&quot;</span>&#125;</span><br><span class="line">train_list1, test_list1 = get_data_list(<span class="number">0</span>, normal_path)</span><br><span class="line">train_list2, test_list2 = get_data_list(<span class="number">1</span>, masked_path)</span><br><span class="line">train_list = train_list1 + train_list2   <span class="comment"># 训练数据集</span></span><br><span class="line">test_list = test_list1 + test_list2      <span class="comment"># 测试数据集</span></span><br><span class="line">random.shuffle(train_list)    <span class="comment"># 获取打乱后的训练集数据</span></span><br><span class="line">random.shuffle(test_list)     <span class="comment"># 获取打乱后的测试集数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 1.3.准备数据提供器 ------</span></span><br><span class="line">BATCH_SIZE, BUF_SIZE = <span class="number">64</span>, <span class="number">512</span></span><br><span class="line">train_reader = paddle.batch(       <span class="comment"># 训练数据提供器</span></span><br><span class="line">    paddle.reader.shuffle(</span><br><span class="line">        data_reader(train_list), buf_size=BUF_SIZE</span><br><span class="line">    ),</span><br><span class="line">    batch_size=BATCH_SIZE,</span><br><span class="line">    drop_last=<span class="literal">True</span>   <span class="comment"># 若最后一批数据少于BATCH_SIZE，则丢弃它</span></span><br><span class="line">)   <span class="comment"># 按批次读取训练数据，批次大小为BATCH_SIZE</span></span><br><span class="line">test_reader = paddle.batch(        <span class="comment"># 测试数据提供器</span></span><br><span class="line">    data_reader(test_list, for_test=<span class="literal">True</span>),</span><br><span class="line">    batch_size=BATCH_SIZE,</span><br><span class="line">    drop_last=<span class="literal">True</span>   <span class="comment"># 若最后一批数据少于BATCH_SIZE，则丢弃它</span></span><br><span class="line">)   <span class="comment"># 按批次读取测试数据，批次大小为BATCH_SIZE</span></span><br></pre></td></tr></table></figure><h2 id="2-网络配置-4">2. 网络配置</h2><ul><li><strong>VGG16模型改进</strong><br>我们采用的模型是改进版的VGG16。原始的VGG16包含13个卷积层、5个池化层、3个全连接层，它常常被用于分类问题。由于本实验的数据集并不是特别大，而实验模型又比较复杂，因此需要改进VGG16模型。<br>为了减少模型的复杂程度，我们选择用一层全局池化层来取代VGG16模型的前两层全连接层（模型结构如下图所示），这样可以大大减少我们需要训练的参数。这对于简化实验模型、防止出现过拟合、提升模型训练速度等，均有很大的帮助。<br><img src="https://img-blog.csdnimg.cn/20210305201657127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RYS19LZXZpbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConvPool</span>(fluid.dygraph.Layer):   <span class="comment"># 定义卷积池化层类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_channels, num_filters, filter_size, pool_size,</span></span><br><span class="line"><span class="params">                 pool_stride, group, conv_stride=<span class="number">1</span>, conv_padding=<span class="number">1</span>, act=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 pool_type=<span class="string">&quot;max&quot;</span>, pool_padding=<span class="number">0</span>, global_pooling=<span class="literal">False</span></span>):  <span class="comment"># 初始化</span></span><br><span class="line">        <span class="built_in">super</span>(ConvPool, self).__init__()</span><br><span class="line">        <span class="comment"># (1) 定义卷积层：</span></span><br><span class="line">        self._conv2d_layers = []    <span class="comment"># 存放卷积层</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(group):      <span class="comment"># 定义group个卷积层</span></span><br><span class="line">            conv2d = self.add_sublayer(</span><br><span class="line">                name=<span class="string">&quot;cov_%d&quot;</span> % i,  <span class="comment"># 子层名</span></span><br><span class="line">                sublayer=Conv2D(</span><br><span class="line">                    num_channels=num_channels,  <span class="comment"># 通道数</span></span><br><span class="line">                    num_filters=num_filters,    <span class="comment"># 卷积核的个数</span></span><br><span class="line">                    filter_size=filter_size,    <span class="comment"># 卷积核的大小</span></span><br><span class="line">                    stride=conv_stride,         <span class="comment"># 卷积运算的步长</span></span><br><span class="line">                    padding=conv_padding,       <span class="comment"># 边界填充大小</span></span><br><span class="line">                    act=act                     <span class="comment"># 激活函数 </span></span><br><span class="line">                )                   <span class="comment"># 添加的子层</span></span><br><span class="line">            )</span><br><span class="line">            num_channels = num_filters</span><br><span class="line">            self._conv2d_layers.append(conv2d)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># (2) 定义池化层：</span></span><br><span class="line">        <span class="keyword">if</span> global_pooling:     <span class="comment"># 是否全局池化</span></span><br><span class="line">            self._pool2d = Pool2D(</span><br><span class="line">                global_pooling=<span class="literal">True</span>,         <span class="comment"># 全局池化</span></span><br><span class="line">                pool_type=pool_type          <span class="comment"># 池化类型</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._pool2d = Pool2D(</span><br><span class="line">                pool_size=pool_size,         <span class="comment"># 池化核的大小</span></span><br><span class="line">                pool_type=pool_type,         <span class="comment"># 池化类型</span></span><br><span class="line">                pool_stride=pool_stride,     <span class="comment"># 池化运算的步长</span></span><br><span class="line">                pool_padding=pool_padding    <span class="comment"># 边界填充大小</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):    <span class="comment"># 前向运算</span></span><br><span class="line">        <span class="keyword">for</span> conv2d <span class="keyword">in</span> self._conv2d_layers:</span><br><span class="line">            x = conv2d(x)</span><br><span class="line">        y = self._pool2d(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VGGNet</span>(fluid.dygraph.Layer):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, class_dim</span>):   <span class="comment"># 初始化VGG网络结构</span></span><br><span class="line">        <span class="built_in">super</span>(VGGNet, self).__init__()</span><br><span class="line">        <span class="comment"># (1) 构建5组卷积池化层：</span></span><br><span class="line">        <span class="comment"># ConvPool(通道数,卷积核数,卷积核大小,池化核大小,池化步长,卷积层数,激活函数)：</span></span><br><span class="line">        self.conv_pool_1 = ConvPool(  <span class="number">3</span>,  <span class="number">64</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, act=<span class="string">&quot;relu&quot;</span>)</span><br><span class="line">        self.conv_pool_2 = ConvPool( <span class="number">64</span>, <span class="number">128</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, act=<span class="string">&quot;relu&quot;</span>)</span><br><span class="line">        self.conv_pool_3 = ConvPool(<span class="number">128</span>, <span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, act=<span class="string">&quot;relu&quot;</span>)</span><br><span class="line">        self.conv_pool_4 = ConvPool(<span class="number">256</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, act=<span class="string">&quot;relu&quot;</span>)</span><br><span class="line">        self.conv_pool_5 = ConvPool(<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, act=<span class="string">&quot;relu&quot;</span>,</span><br><span class="line">                                    pool_type=<span class="string">&quot;avg&quot;</span>, global_pooling=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># (2) 构建全连接层：</span></span><br><span class="line">        <span class="comment"># Linear(输入维度, 输出维度, 激活函数)：</span></span><br><span class="line">        self.fc_layer = Linear(<span class="number">512</span>, class_dim, act=<span class="string">&quot;softmax&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span>, label=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># (1) 前向计算：</span></span><br><span class="line">        x = <span class="built_in">input</span>                   <span class="comment"># 输入的维度为3*224*224</span></span><br><span class="line">        x = self.conv_pool_1(x)     <span class="comment"># 输出的维度为64*112*112</span></span><br><span class="line">        x = self.conv_pool_2(x)     <span class="comment"># 输出的维度为128*56*56</span></span><br><span class="line">        x = self.conv_pool_3(x)     <span class="comment"># 输出的维度为256*28*28</span></span><br><span class="line">        x = self.conv_pool_4(x)     <span class="comment"># 输出的维度为512*14*14</span></span><br><span class="line">        x = self.conv_pool_5(x)     <span class="comment"># 输出的维度为512*1*1</span></span><br><span class="line">        x = fluid.layers.squeeze(x, axes=[])  <span class="comment"># 去除多余维度</span></span><br><span class="line">        y = self.fc_layer(x)        <span class="comment"># 输出的维度为2</span></span><br><span class="line">        <span class="comment"># (2) 返回结果：</span></span><br><span class="line">        <span class="keyword">if</span> label <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            acc = fluid.layers.accuracy(<span class="built_in">input</span>=y, label=label)</span><br><span class="line">            <span class="keyword">return</span> y, acc           <span class="comment"># 返回预测结果和准确率</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> y                <span class="comment"># 仅返回预测结果</span></span><br></pre></td></tr></table></figure><h2 id="3-模型训练-4">3. 模型训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">EPOCH_NUM, train_iter = <span class="number">5</span>, <span class="number">0</span></span><br><span class="line">train_plt = Ploter(<span class="string">&quot;Train Loss&quot;</span>, <span class="string">&quot;Train Acc&quot;</span>)  <span class="comment"># 构建Ploter对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_graph</span>(<span class="params">ploter, title, x, y</span>):     <span class="comment"># 动态绘制图像</span></span><br><span class="line">    ploter.append(title, x, y)</span><br><span class="line">    ploter.plot()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():   <span class="comment"># 使用动态图进行模型训练</span></span><br><span class="line">    model = VGGNet(<span class="number">2</span>)   <span class="comment"># 实例化模型</span></span><br><span class="line">    model.train()       <span class="comment"># 开启训练模式</span></span><br><span class="line">    opt = fluid.optimizer.Adam(</span><br><span class="line">        learning_rate=fluid.dygraph.NaturalExpDecay(</span><br><span class="line">            learning_rate=<span class="number">1e-4</span>,  <span class="comment"># 初始学习率</span></span><br><span class="line">            decay_steps=<span class="number">150</span>,     <span class="comment"># 学习率衰减步长</span></span><br><span class="line">            decay_rate=<span class="number">0.25</span>      <span class="comment"># 学习率衰减率</span></span><br><span class="line">        ),  <span class="comment"># 学习率呈现指数衰减</span></span><br><span class="line">        parameter_list=model.parameters()</span><br><span class="line">    )   <span class="comment"># 定义优化器，使用Adam优化算法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pass_id <span class="keyword">in</span> <span class="built_in">range</span>(EPOCH_NUM):   <span class="comment"># 训练EPOCH_NUM轮</span></span><br><span class="line">        <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_reader()):</span><br><span class="line">            image = np.array([x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> data]).astype(<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">            label = np.array([x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> data]).astype(<span class="string">&quot;int64&quot;</span>)</span><br><span class="line">            label = label[:, np.newaxis]    <span class="comment"># 在label中增加一个维度</span></span><br><span class="line">            <span class="comment"># 将数据转化为fluid.dygraph能够接受的Variable类型的对象：</span></span><br><span class="line">            image = fluid.dygraph.to_variable(image)</span><br><span class="line">            label = fluid.dygraph.to_variable(label)</span><br><span class="line"></span><br><span class="line">            predict, accuracy = model(image, label)            <span class="comment"># 训练模型</span></span><br><span class="line">            loss = fluid.layers.cross_entropy(predict, label)  <span class="comment"># 计算交叉熵</span></span><br><span class="line">            avg_loss = fluid.layers.mean(loss)                 <span class="comment"># 求平均损失值</span></span><br><span class="line"></span><br><span class="line">            train_iter += <span class="number">1</span></span><br><span class="line">            train_loss = np.mean(avg_loss.numpy())</span><br><span class="line">            train_acc = np.mean(accuracy.numpy())</span><br><span class="line">            <span class="keyword">if</span> batch_id % <span class="number">15</span> == <span class="number">0</span>:          <span class="comment"># 每15个批次绘制一次图形</span></span><br><span class="line">                draw_graph(train_plt, <span class="string">&quot;Train Loss&quot;</span>, train_iter, train_loss)</span><br><span class="line">                draw_graph(train_plt, <span class="string">&quot;Train Acc&quot;</span>, train_iter, train_acc)</span><br><span class="line">            <span class="keyword">if</span> batch_id % <span class="number">75</span> == <span class="number">0</span>:          <span class="comment"># 每75批次输出一次训练结果</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Pass：%2d；Batch：%3d；AvgLoss：%.6f；Accuracy：%.4f&quot;</span> % </span><br><span class="line">                        (pass_id+<span class="number">1</span>, batch_id, train_loss, train_acc))</span><br><span class="line">            </span><br><span class="line">            avg_loss.backward()       <span class="comment"># 反向传播平均损失值</span></span><br><span class="line">            opt.minimize(avg_loss)    <span class="comment"># 调用优化器中的方法更新参数</span></span><br><span class="line">            model.clear_gradients()   <span class="comment"># 重置梯度以保证下轮训练的正确性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&quot;./MaskVGG.pdparams&quot;</span>):</span><br><span class="line">        os.remove(<span class="string">&quot;./MaskVGG.pdparams&quot;</span>)</span><br><span class="line">    fluid.save_dygraph(model.state_dict(), <span class="string">&quot;MaskVGG&quot;</span>)   <span class="comment"># 保存训练好的模型</span></span><br></pre></td></tr></table></figure><p>模型训练结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass： 1；Batch：  0；AvgLoss：0.701839；Accuracy：0.5156</span><br><span class="line">Pass： 1；Batch： 75；AvgLoss：0.181599；Accuracy：0.9531</span><br><span class="line">Pass： 1；Batch：150；AvgLoss：0.230531；Accuracy：0.9531</span><br><span class="line">Pass： 2；Batch：  0；AvgLoss：0.179746；Accuracy：0.9375</span><br><span class="line">Pass： 2；Batch： 75；AvgLoss：0.067900；Accuracy：0.9688</span><br><span class="line">Pass： 2；Batch：150；AvgLoss：0.105858；Accuracy：0.9531</span><br><span class="line">Pass： 3；Batch：  0；AvgLoss：0.064703；Accuracy：0.9844</span><br><span class="line">Pass： 3；Batch： 75；AvgLoss：0.099208；Accuracy：0.9688</span><br><span class="line">Pass： 3；Batch：150；AvgLoss：0.226084；Accuracy：0.9219</span><br><span class="line">Pass： 4；Batch：  0；AvgLoss：0.141472；Accuracy：0.9688</span><br><span class="line">Pass： 4；Batch： 75；AvgLoss：0.070129；Accuracy：0.9688</span><br><span class="line">Pass： 4；Batch：150；AvgLoss：0.051304；Accuracy：0.9844</span><br><span class="line">Pass： 5；Batch：  0；AvgLoss：0.170740；Accuracy：0.9219</span><br><span class="line">Pass： 5；Batch： 75；AvgLoss：0.037117；Accuracy：1.0000</span><br><span class="line">Pass： 5；Batch：150；AvgLoss：0.029966；Accuracy：0.9844</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210319232912218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RYS19LZXZpbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="4-模型评估-4">4. 模型评估</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_iter = <span class="number">0</span></span><br><span class="line">test_costs, test_accs = [], []        <span class="comment"># 存放测试损失值和准确率</span></span><br><span class="line">test_plt = Ploter(<span class="string">&quot;Test Loss&quot;</span>, <span class="string">&quot;Test Acc&quot;</span>)  <span class="comment"># 构建Ploter对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():   <span class="comment"># 使用动态图进行模型评估</span></span><br><span class="line">    model = VGGNet(<span class="number">2</span>)   <span class="comment"># 实例化模型</span></span><br><span class="line">    model_dict, _ = fluid.load_dygraph(<span class="string">&quot;MaskVGG&quot;</span>)   <span class="comment"># 加载保存的模型参数</span></span><br><span class="line">    model.load_dict(model_dict)               <span class="comment"># 将模型参数载入到新模型中</span></span><br><span class="line">    model.<span class="built_in">eval</span>()        <span class="comment"># 开启评估模式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_reader()):</span><br><span class="line">        image = np.array([x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> data]).astype(<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">        label = np.array([x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> data]).astype(<span class="string">&quot;int64&quot;</span>)</span><br><span class="line">        label = label[:, np.newaxis]    <span class="comment"># 在label中增加一个维度</span></span><br><span class="line">        <span class="comment"># 将数据转化为fluid.dygraph能够接受的Variable类型的对象：</span></span><br><span class="line">        image = fluid.dygraph.to_variable(image)</span><br><span class="line">        label = fluid.dygraph.to_variable(label)</span><br><span class="line"></span><br><span class="line">        predict, accuracy = model(image, label)             <span class="comment"># 模型测试</span></span><br><span class="line">        loss = fluid.layers.cross_entropy(predict, label)   <span class="comment"># 计算交叉熵</span></span><br><span class="line">        avg_loss = fluid.layers.mean(loss)                  <span class="comment"># 求平均损失值</span></span><br><span class="line"></span><br><span class="line">        test_iter += <span class="number">1</span></span><br><span class="line">        test_costs.append(np.mean(avg_loss.numpy()))        <span class="comment"># 测试误差值</span></span><br><span class="line">        test_accs.append(np.mean(accuracy.numpy()))         <span class="comment"># 测试准确率</span></span><br><span class="line">        draw_graph(test_plt, <span class="string">&quot;Test Loss&quot;</span>, test_iter, test_costs[-<span class="number">1</span>])</span><br><span class="line">        draw_graph(test_plt, <span class="string">&quot;Test Acc&quot;</span>, test_iter, test_accs[-<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test \t Avg_Loss：%.5f；Accuracy：%.5f&quot;</span> %</span><br><span class="line">            (np.mean(test_costs), np.mean(test_accs)))      <span class="comment"># 平均损失、平均准确率</span></span><br></pre></td></tr></table></figure><p>模型评估结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eval  Avg_Loss：0.04104；Accuracy：0.98958</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210319233108851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RYS19LZXZpbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="5-模型预测-4">5. 模型预测</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_image</span>(<span class="params">img_path</span>):     <span class="comment"># 打开与处理图片</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(img_path).convert(<span class="string">&quot;RGB&quot;</span>)      <span class="comment"># 以RGB模式打开图片</span></span><br><span class="line">    img = img.resize((<span class="number">224</span>, <span class="number">224</span>), Image.ANTIALIAS)  <span class="comment"># 以抗锯齿模式缩放图片</span></span><br><span class="line">    display(img)    <span class="comment"># 展示图片</span></span><br><span class="line">    img = np.array(img).astype(<span class="string">&quot;float32&quot;</span>)         <span class="comment"># 将图像转化成numpy数组形式</span></span><br><span class="line">    img = img.transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))  <span class="comment"># 将图像矩阵由“rgb,rgb,...”转置为“rr..,gg..,bb..”</span></span><br><span class="line">    <span class="keyword">return</span> img / <span class="number">255.0</span>              <span class="comment"># 返回归一化后的图像数组</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():   <span class="comment"># 使用动态图进行模型预测</span></span><br><span class="line">    model = VGGNet(<span class="number">2</span>)   <span class="comment"># 实例化模型</span></span><br><span class="line">    model_dict, _ = fluid.load_dygraph(<span class="string">&quot;MaskVGG&quot;</span>)  <span class="comment"># 加载保存的模型参数</span></span><br><span class="line">    model.load_dict(model_dict)               <span class="comment"># 将模型参数载入到新模型中</span></span><br><span class="line">    model.<span class="built_in">eval</span>()        <span class="comment"># 开启评估模式</span></span><br><span class="line"></span><br><span class="line">    infer_paths = [<span class="string">&quot;n1.jpg&quot;</span>, <span class="string">&quot;m1.jpg&quot;</span>, <span class="string">&quot;n2.jpg&quot;</span>, <span class="string">&quot;m2.jpg&quot;</span>]  <span class="comment"># 预测图像名</span></span><br><span class="line">    <span class="keyword">for</span> index, path <span class="keyword">in</span> <span class="built_in">enumerate</span>(infer_paths):</span><br><span class="line">        infer_img = load_image(<span class="string">&quot;work/%s&quot;</span> % path)     <span class="comment"># 打开预测图像</span></span><br><span class="line">        infer_img = np.array(infer_img).astype(<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">        infer_img = infer_img[np.newaxis, :, :, :]   <span class="comment"># 在最前面新增一维</span></span><br><span class="line">        infer_img = fluid.dygraph.to_variable(infer_img)</span><br><span class="line"></span><br><span class="line">        result = model(infer_img)              <span class="comment"># 模型预测，返回一个概率值数组</span></span><br><span class="line">        lab = np.argmax(result.numpy())        <span class="comment"># 获取result数组最大值的索引值</span></span><br><span class="line">        infer_lab = lab_dict[<span class="built_in">str</span>(lab)]         <span class="comment"># 获取预测的结果</span></span><br><span class="line">        infer_prob = result.numpy()[lab]       <span class="comment"># 获取结果的概率</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;图%d的预测结果为：%s（%.3f）\n&quot;</span> % (index+<span class="number">1</span>, infer_lab, infer_prob))</span><br></pre></td></tr></table></figure><p>模型预测结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图1的预测结果为：没戴口罩（0.855）</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210319233343385.jpg" alt=""></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图2的预测结果为：戴了口罩（0.993）</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210319233343398.jpg" alt=""></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图3的预测结果为：没戴口罩（0.923）</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210319233343417.jpg" alt=""></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图4的预测结果为：戴了口罩（1.000）</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210211232816712.png" alt=""></p><hr/><blockquote><h1>写在最后</h1><ul><li>如果您发现项目存在问题，或者如果您有更好的建议，欢迎在下方评论区中留言讨论~</li><li>这是本项目的链接：<a href="https://aistudio.baidu.com/aistudio/projectdetail/844191?shared=1">实验项目 - AI Studio</a>，点击<code>fork</code>可直接在AI Studio运行~</li><li>这是我的个人主页：<a href="https://aistudio.baidu.com/aistudio/personalcenter/thirdview/118633">个人主页 - AI Studio</a>，来AI Studio互粉吧，等你哦~</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【VGG19】海洋生物识别</title>
      <link href="/2021/03/10/%E3%80%90VGG19%E3%80%91%E6%B5%B7%E6%B4%8B%E7%94%9F%E7%89%A9%E8%AF%86%E5%88%AB/"/>
      <url>/2021/03/10/%E3%80%90VGG19%E3%80%91%E6%B5%B7%E6%B4%8B%E7%94%9F%E7%89%A9%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1>问题导入</h1><p>图像分类是根据图像的语义信息将不同类别图像区分开来，是计算机视觉中重要的基本问题。本实践使用卷积神经网络VGG19模型构建深度学习模型，自动提取高质量的特征，来解决海洋鱼类识别的问题。</p><hr/><h1>一、VGG模型</h1><ul><li>VGG 是由 Simonyan 和 Zisserman 在论文 “<a href="https://arxiv.org/abs/1409.1556">Very Deep Convolutional Networks for Large Scale Image Recognition</a>” 中提出卷积神经网络模型，其名称来源于作者所在的牛津大学视觉几何组 (Visual Geometry Group) 的缩写。</li><li>VGG 中根据卷积核大小和卷积层数目的不同，可分为 A、A-LRN、B、C、D、E 共6个配置 (ConvNet Configuration)，其中以 D 和 E 两种配置较为常用，分别称为 VGG16 和 VGG19。本实验使用的是VGG19模型（模型结构如下图 type E 所示）。<br><img src="https://img-blog.csdnimg.cn/img_convert/62b9772f507d42b9d9170eecd7f32735.png#pic_center" alt=""></li></ul><hr/><h1>二、数据集简介</h1><p>本次实验使用的是台湾电力公司、台湾海洋研究所和垦丁国家公园在2010年10月1日至2013年9月30日期间，在中国台湾南湾海峡、兰屿岛和胡比湖的水下观景台收集的鱼类图像数据集。<br>该数据集包括23类鱼种，共27370张鱼的图像，本次实验将取其中的90%作为训练集，剩下的10%作为测试集。<br><img src="https://img-blog.csdnimg.cn/4cc0a86054fa4303836fdf852ae281dd.png#pic_center" alt=""></p><blockquote><p>这是数据集的下载链接：<a href="https://aistudio.baidu.com/aistudio/datasetdetail/14492">Fish4Knowledge 23种鱼类数据集 - AI Studio</a></p></blockquote><hr/><h1>三、实验步骤</h1><h2 id="0-导入模块-6">0. 导入模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">from</span> paddle <span class="keyword">import</span> fluid</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> cpu_count</span><br></pre></td></tr></table></figure><h2 id="1-数据准备-4">1. 数据准备</h2><ul><li><strong>数据预处理</strong></li></ul><blockquote><p>（1）由于数据集中的数据是以压缩包的形式存放的，因此我们需要先解压数据压缩包。<br>（2）接着，我们需要按1:9比例划分测试集和训练集，分别生成包含数据地址的两个列表。<br>（3）然后，我们需要分别构建用于训练和测试的数据提供器，其中训练数据提供器是乱序、按批次提供数据的。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unzip_data</span>(<span class="params">target_path</span>):      <span class="comment"># 将原数据集解压至指定路径</span></span><br><span class="line">    SRC_PATH = <span class="string">&quot;./data/data14492/fish_image23.zip&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(target_path):</span><br><span class="line">        z = zipfile.ZipFile(SRC_PATH, <span class="string">&#x27;r&#x27;</span>)   <span class="comment"># 打开Zip文件，创建Zip对象</span></span><br><span class="line">        z.extractall(path=<span class="string">&quot;./data/&quot;</span>)         <span class="comment"># 解压Zip文件至target_path</span></span><br><span class="line">        z.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数据集解压完成！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_mapper</span>(<span class="params">sample</span>):</span><br><span class="line">    img_path, label = sample</span><br><span class="line">    img = paddle.dataset.image.simple_transform(</span><br><span class="line">        im=paddle.dataset.image.load_image(img_path),    <span class="comment"># 待变换的图片</span></span><br><span class="line">        resize_size=<span class="number">224</span>,  <span class="comment"># 将图像缩放为224*224像素的图片</span></span><br><span class="line">        crop_size=<span class="number">224</span>,    <span class="comment"># crop修剪操作，修剪后的图像大小为224*224像素</span></span><br><span class="line">        is_color=<span class="literal">True</span>,    <span class="comment"># 是否为RGB彩色图片</span></span><br><span class="line">        is_train=<span class="literal">True</span>     <span class="comment"># 是否为训练集，true为随机剪裁，False为中心剪裁</span></span><br><span class="line">    )</span><br><span class="line">    img = img.flatten().astype(<span class="string">&quot;float32&quot;</span>) / <span class="number">255.0</span>   <span class="comment"># 归一化处理img数组</span></span><br><span class="line">    <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_reader</span>(<span class="params">data_list</span>):   <span class="comment"># 按批量读取图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reader</span>():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> data_list:</span><br><span class="line">            img_path, label = data[<span class="number">0</span>], data[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">yield</span> img_path, <span class="built_in">int</span>(label)</span><br><span class="line">    <span class="keyword">return</span> paddle.reader.xmap_readers(data_mapper, reader, cpu_count(), <span class="number">1024</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------ 1.1.解压数据集 ------</span></span><br><span class="line">data_path = <span class="string">&quot;./data/fish_image&quot;</span>          <span class="comment"># 数据集路径</span></span><br><span class="line">unzip_data(data_path)                    <span class="comment"># 解压原数据集至指定路径</span></span><br><span class="line">file_folders = os.listdir(data_path)     <span class="comment"># data_path路径下的文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 1.2.划分数据集 ------</span></span><br><span class="line">train_list, test_list = [], []      <span class="comment"># 存放训练集和数据集的位置以及类别</span></span><br><span class="line">type_num, lab_dict = <span class="number">0</span>, &#123;&#125;          <span class="comment"># 方便动物类别在字符型和整型之间转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> folder <span class="keyword">in</span> file_folders:</span><br><span class="line">    lab_dict[<span class="built_in">str</span>(type_num)] = folder      <span class="comment"># 记录标签和数字代号的对应关系</span></span><br><span class="line">    images = os.listdir(os.path.join(data_path, folder))</span><br><span class="line">    <span class="keyword">for</span> idx, img <span class="keyword">in</span> <span class="built_in">enumerate</span>(images):</span><br><span class="line">        img_path = os.path.join(data_path, folder, img)</span><br><span class="line">        value = [img_path, type_num]      <span class="comment"># 记录图片链接及其标签代号</span></span><br><span class="line">        <span class="keyword">if</span> idx % <span class="number">10</span> == <span class="number">0</span>:      <span class="comment"># 按照1:9的比例划分数据集</span></span><br><span class="line">            test_list.append(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            train_list.append(value)</span><br><span class="line">    type_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">random.shuffle(train_list)    <span class="comment"># 打乱训练集数据</span></span><br><span class="line">random.shuffle(test_list)     <span class="comment"># 打乱测试集数据        </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 1.3.准备训练数据集 ------</span></span><br><span class="line">BUF_SIZE, BATCH_SIZE = <span class="number">1024</span>, <span class="number">64</span></span><br><span class="line">train_reader = paddle.batch(</span><br><span class="line">    paddle.reader.shuffle(</span><br><span class="line">        data_reader(train_list), buf_size=BUF_SIZE</span><br><span class="line">    ),  <span class="comment"># 每次缓存BUF_SIZE个训练数据项，并打乱</span></span><br><span class="line">    batch_size=BATCH_SIZE</span><br><span class="line">)   <span class="comment"># 按批次读取乱序后的训练数据，批次大小为BATCH_SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 1.4.准备测试数据集 ------</span></span><br><span class="line">test_reader = paddle.batch(</span><br><span class="line">    data_reader(test_list), batch_size=BATCH_SIZE</span><br><span class="line">)   <span class="comment"># 按批次读取测试数据，批次大小为BATCH_SIZE</span></span><br></pre></td></tr></table></figure><h2 id="2-网络配置-3">2. 网络配置</h2><ul><li><strong>实验模型</strong><br>本实验采用的是VGG19模型，VGG19常常被用于分类问题。它包含16个卷积层、5个池化层、3个全连接层。其中，卷积层和全连接层具有权重系数，且它们的总数为19，故该模型被称为VGG19。<br><img src="https://img-blog.csdnimg.cn/50fdcab98907472e969245a25ef5d2e7.jpeg#pic_center" alt=""></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conv_block</span>(<span class="params"><span class="built_in">input</span>, num_filter, groups, dropouts</span>):  <span class="comment"># 定义卷积操作</span></span><br><span class="line">    <span class="keyword">return</span> fluid.nets.img_conv_group(</span><br><span class="line">        <span class="built_in">input</span>=<span class="built_in">input</span>,                             </span><br><span class="line">        conv_num_filter=[num_filter] * groups,  <span class="comment"># 卷积核的个数</span></span><br><span class="line">        conv_filter_size=<span class="number">3</span>,                     <span class="comment"># 卷积核的大小</span></span><br><span class="line">        conv_act=<span class="string">&#x27;relu&#x27;</span>,                        <span class="comment"># 卷积层的激活函数</span></span><br><span class="line">        pool_size=<span class="number">2</span>,                            <span class="comment"># 池化核的大小</span></span><br><span class="line">        pool_stride=<span class="number">2</span>,                          <span class="comment"># 池化核的步长</span></span><br><span class="line">        pool_type=<span class="string">&#x27;max&#x27;</span>,                        <span class="comment"># 池化类型：最大池化</span></span><br><span class="line">        conv_with_batchnorm=<span class="literal">True</span>,               <span class="comment"># 在卷积-池化层后是否使用BatchNorm</span></span><br><span class="line">        conv_batchnorm_drop_rate=dropouts       <span class="comment"># BatchNorm之后的Dropout层的丢弃概率</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_VGG_model</span>(<span class="params"><span class="built_in">input</span>, class_dim</span>):  <span class="comment"># 定义VGG网络</span></span><br><span class="line">    <span class="comment"># (1) 定义五个卷积-池化block：</span></span><br><span class="line">    conv1 = conv_block(<span class="built_in">input</span>, <span class="number">64</span>, <span class="number">2</span>, [<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    conv2 = conv_block(conv1, <span class="number">128</span>, <span class="number">2</span>, [<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    conv3 = conv_block(conv2, <span class="number">256</span>, <span class="number">4</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    conv4 = conv_block(conv3, <span class="number">512</span>, <span class="number">4</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    conv5 = conv_block(conv4, <span class="number">512</span>, <span class="number">4</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="comment"># (2) 定义三组全连接层：</span></span><br><span class="line">    fc1 = fluid.layers.fc(<span class="built_in">input</span>=conv5, size=<span class="number">512</span>, act=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">    drop1 = fluid.layers.dropout(x=fc1, dropout_prob=<span class="number">0.5</span>)</span><br><span class="line">    fc2 = fluid.layers.fc(<span class="built_in">input</span>=drop1, size=<span class="number">512</span>, act=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">    drop2 = fluid.layers.dropout(x=fc2, dropout_prob=<span class="number">0.5</span>)</span><br><span class="line">    output = fluid.layers.fc(<span class="built_in">input</span>=drop2, size=class_dim, act=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------ 2.1.定义数据层和分类器 ------</span></span><br><span class="line"><span class="comment"># 定义输入的图像张量，图像为“3通道、224*224”的彩色图片：</span></span><br><span class="line">image = fluid.data(name=<span class="string">&quot;image&quot;</span>, shape=[<span class="literal">None</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>], dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"><span class="comment"># 定义标签张量，对应输入图像的类别标签：</span></span><br><span class="line">label = fluid.data(name=<span class="string">&quot;label&quot;</span>, shape=[<span class="literal">None</span>, <span class="number">1</span>], dtype=<span class="string">&quot;int64&quot;</span>)</span><br><span class="line"><span class="comment"># 获取定义的分类器：</span></span><br><span class="line">predict = initialize_VGG_model(image, type_num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 2.2.定义损失函数和准确率函数 ------</span></span><br><span class="line">cost = fluid.layers.cross_entropy(<span class="built_in">input</span>=predict, label=label)  <span class="comment"># 计算交叉熵</span></span><br><span class="line">avg_cost = fluid.layers.mean(cost)                           <span class="comment"># 计算平均损失</span></span><br><span class="line">accuracy = fluid.layers.accuracy(<span class="built_in">input</span>=predict, label=label)   <span class="comment"># 计算准确率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 2.3.定义优化算法 ------</span></span><br><span class="line"><span class="comment"># Adam是基于梯度下降的算法，Adam()函数实现了自适应矩估计优化器：</span></span><br><span class="line">optimizer = fluid.optimizer.Adam(</span><br><span class="line">    learning_rate=fluid.layers.natural_exp_decay(</span><br><span class="line">        learning_rate=<span class="number">1e-4</span>,  <span class="comment"># 初始学习率</span></span><br><span class="line">        decay_steps=<span class="number">700</span>,      <span class="comment"># 学习率衰减步长</span></span><br><span class="line">        decay_rate=<span class="number">0.5</span>,       <span class="comment"># 学习率衰减率</span></span><br><span class="line">        staircase=<span class="literal">True</span>        <span class="comment"># 每decay_steps步学习率衰减为原来的decay_rate</span></span><br><span class="line">    )   <span class="comment"># 学习率呈现指数衰减</span></span><br><span class="line">)</span><br><span class="line">opts = optimizer.minimize(avg_cost)</span><br></pre></td></tr></table></figure><h2 id="3-训练与评估">3. 训练与评估</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------ 3.1.创建训练用Executor ------</span></span><br><span class="line">use_cuda = <span class="literal">True</span>    <span class="comment"># True代表使用GPU，False代表使用CPU</span></span><br><span class="line">place = fluid.CUDAPlace(<span class="number">0</span>) <span class="keyword">if</span> use_cuda <span class="keyword">else</span> fluid.CPUPlace()  <span class="comment"># 指定运行环境</span></span><br><span class="line">exe = fluid.Executor(place)</span><br><span class="line">exe.run(fluid.default_startup_program())   <span class="comment"># 运行初始化操作函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 3.2.定义数据映射器 ------</span></span><br><span class="line">feeder = fluid.DataFeeder(place=place, feed_list=[image, label])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 3.3.开始训练模型 ------</span></span><br><span class="line">EPOCH_NUM, train_iter = <span class="number">5</span>, <span class="number">0</span></span><br><span class="line">train_iters, train_costs, train_accs = [], [], []</span><br><span class="line">test_program = fluid.default_main_program().clone(for_test=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 注：这里的clone并不是单纯的复制，训练函数和测试函数的机制略有不同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pass_id <span class="keyword">in</span> <span class="built_in">range</span>(EPOCH_NUM):    <span class="comment"># 训练EPOCH_NUM轮</span></span><br><span class="line">    <span class="comment"># (1) 进行训练：</span></span><br><span class="line">    <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_reader()):</span><br><span class="line">        train_cost, train_acc = exe.run(</span><br><span class="line">            program=fluid.default_main_program(),  <span class="comment"># 运行主程序</span></span><br><span class="line">            feed=feeder.feed(data),                <span class="comment"># 给模型喂入数据</span></span><br><span class="line">            fetch_list=[avg_cost, accuracy]        <span class="comment"># 返回误差、准确率</span></span><br><span class="line">        )</span><br><span class="line">        train_iter += BATCH_SIZE</span><br><span class="line">        train_iters.append(train_iter)       <span class="comment"># 迭代次数</span></span><br><span class="line">        train_costs.append(train_cost[<span class="number">0</span>])    <span class="comment"># 训练误差</span></span><br><span class="line">        train_accs.append(train_acc[<span class="number">0</span>])      <span class="comment"># 训练准确率</span></span><br><span class="line">        <span class="keyword">if</span> batch_id != <span class="number">0</span> <span class="keyword">and</span> batch_id % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Pass：%2d；Batch：%3d；Cost：%.6f；Accuracy：%.4f&quot;</span> % </span><br><span class="line">                (pass_id, batch_id, train_cost[<span class="number">0</span>], train_acc[<span class="number">0</span>]))</span><br><span class="line">    <span class="comment"># (2) 进行测试：</span></span><br><span class="line">    test_costs, test_accs = [], []</span><br><span class="line">    <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_reader()):</span><br><span class="line">        test_cost, test_acc = exe.run(</span><br><span class="line">            program=test_program,            <span class="comment"># 运行测试程序</span></span><br><span class="line">            feed=feeder.feed(data),          <span class="comment"># 给模型喂入数据</span></span><br><span class="line">            fetch_list=[avg_cost, accuracy]  <span class="comment"># 返回误差、准确率</span></span><br><span class="line">        )</span><br><span class="line">        test_costs.append(test_cost[<span class="number">0</span>])   <span class="comment"># 测试误差</span></span><br><span class="line">        test_accs.append(test_acc[<span class="number">0</span>])     <span class="comment"># 测试准确率</span></span><br><span class="line">    test_cost, test_acc = np.mean(test_costs), np.mean(test_accs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test：%2d；Cost：%.6f；Accuracy：%.4f&quot;</span> % (pass_id, test_cost, test_acc))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 3.4.保存训练模型 ------</span></span><br><span class="line">model_save_dir = <span class="string">&quot;/home/aistudio/fish.inference.model&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(model_save_dir):</span><br><span class="line">    os.makedirs(model_save_dir)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n save models to %s&#x27;</span> % (model_save_dir))</span><br><span class="line"><span class="comment"># 保存训练参数到指定路径中，构建一个专门用预测的program：</span></span><br><span class="line">fluid.io.save_inference_model(model_save_dir,  <span class="comment"># 保存推理模型的路径</span></span><br><span class="line">                              [<span class="string">&#x27;image&#x27;</span>],       <span class="comment"># 推理(inference)需要喂入的数据</span></span><br><span class="line">                              [predict],       <span class="comment"># 保存推理(inference)结果的变量</span></span><br><span class="line">                              exe)             <span class="comment"># exe保存inference model</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass： 0；Batch：100；Cost：1.040119；Accuracy：0.7500</span><br><span class="line">Pass： 0；Batch：200；Cost：0.536092；Accuracy：0.8281</span><br><span class="line">Pass： 0；Batch：300；Cost：0.520832；Accuracy：0.8594</span><br><span class="line">Test： 0；Cost：0.323051；Accuracy：0.9153</span><br><span class="line">Pass： 1；Batch：100；Cost：0.749455；Accuracy：0.8594</span><br><span class="line">Pass： 1；Batch：200；Cost：0.337793；Accuracy：0.9062</span><br><span class="line">Pass： 1；Batch：300；Cost：0.310903；Accuracy：0.9375</span><br><span class="line">Test： 1；Cost：0.185656；Accuracy：0.9541</span><br><span class="line">Pass： 2；Batch：100；Cost：0.376315；Accuracy：0.8906</span><br><span class="line">Pass： 2；Batch：200；Cost：0.157916；Accuracy：0.9531</span><br><span class="line">Pass： 2；Batch：300；Cost：0.217635；Accuracy：0.9219</span><br><span class="line">Test： 2；Cost：0.156149；Accuracy：0.9570</span><br><span class="line">Pass： 3；Batch：100；Cost：0.622780；Accuracy：0.8750</span><br><span class="line">Pass： 3；Batch：200；Cost：0.089484；Accuracy：0.9688</span><br><span class="line">Pass： 3；Batch：300；Cost：0.113488；Accuracy：0.9688</span><br><span class="line">Test： 3；Cost：0.134475；Accuracy：0.9661</span><br><span class="line">Pass： 4；Batch：100；Cost：0.231211；Accuracy：0.9531</span><br><span class="line">Pass： 4；Batch：200；Cost：0.137994；Accuracy：0.9844</span><br><span class="line">Pass： 4；Batch：300；Cost：0.127923；Accuracy：0.9688</span><br><span class="line">Test： 4；Cost：0.110910；Accuracy：0.9687</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_training_loss</span>(<span class="params">iters, costs</span>):    <span class="comment"># 绘制训练误差图像</span></span><br><span class="line">    plt.figure(figsize=[<span class="number">10</span>, <span class="number">5</span>])</span><br><span class="line">    plt.title(<span class="string">&quot;Training Loss&quot;</span>, fontsize=<span class="number">25</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;iter&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;loss&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">    plt.plot(iters, costs, color=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_training_acc</span>(<span class="params">iters, accs</span>):     <span class="comment"># 绘制训练准确率图像</span></span><br><span class="line">    plt.figure(figsize=[<span class="number">10</span>, <span class="number">5</span>])</span><br><span class="line">    plt.title(<span class="string">&quot;Training Accuracy&quot;</span>, fontsize=<span class="number">25</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;iter&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;accuracy&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">    plt.plot(iters, accs, color=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------ 3.5.绘制模型训练曲线 ------</span></span><br><span class="line">draw_training_loss(train_iters, train_costs)        <span class="comment"># 绘制训练损失值图像</span></span><br><span class="line">draw_training_acc(train_iters, train_accs)          <span class="comment"># 绘制训练准确率图像</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ff187e96c3a342d987fd60eb3e1a20bd.png#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/8e7038ff2bc64bc89013b846ce048320.png#pic_center" alt=""></p><h2 id="4-模型预测">4. 模型预测</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_image</span>(<span class="params">path</span>):         <span class="comment"># 预测图片预处理</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(path)    <span class="comment"># 打开图像</span></span><br><span class="line">    plt.imshow(img)   <span class="comment"># 展示图片</span></span><br><span class="line">    plt.show()</span><br><span class="line">    img = img.resize((<span class="number">224</span>, <span class="number">224</span>), Image.ANTIALIAS)  <span class="comment"># 将图像缩放为224*224的高质量图像</span></span><br><span class="line">    img = np.array(img).reshape(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)\</span><br><span class="line">        .astype(<span class="string">&#x27;float32&#x27;</span>)     <span class="comment"># 把图像变成numpy数组以匹配数据馈送格式</span></span><br><span class="line">    <span class="keyword">return</span> img / <span class="number">255.0</span>         <span class="comment"># 返回归一化后的数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">match_labels</span>(<span class="params">lab_dict</span>):   <span class="comment"># 返回将标签进行转换的字典</span></span><br><span class="line">    temp = &#123;<span class="string">&#x27;fish_1&#x27;</span>: <span class="string">&#x27;Dascyllus reticulatus&#x27;</span>, <span class="string">&#x27;fish_2&#x27;</span>: <span class="string">&#x27;Plectroglyphidodon dickii&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;fish_3&#x27;</span>: <span class="string">&#x27;Chromis chrysura&#x27;</span>, <span class="string">&#x27;fish_4&#x27;</span>: <span class="string">&#x27;Amphiprion clarkii&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;fish_5&#x27;</span>: <span class="string">&#x27;Chaetodon lunulatus&#x27;</span>, <span class="string">&#x27;fish_6&#x27;</span>: <span class="string">&#x27;Chaetodon trifascialis&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;fish_7&#x27;</span>: <span class="string">&#x27;Myripristis kuntee&#x27;</span>, <span class="string">&#x27;fish_8&#x27;</span>: <span class="string">&#x27;Acanthurus nigrofuscus&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;fish_9&#x27;</span>: <span class="string">&#x27;Hemigymnus fasciatus&#x27;</span>, <span class="string">&#x27;fish_10&#x27;</span>: <span class="string">&#x27;Neoniphon sammara&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;fish_11&#x27;</span>: <span class="string">&#x27;Abudefduf vaigiensis&#x27;</span>, <span class="string">&#x27;fish_12&#x27;</span>: <span class="string">&#x27;Canthigaster valentini&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;fish_13&#x27;</span>: <span class="string">&#x27;Pomacentrus moluccensis&#x27;</span>, <span class="string">&#x27;fish_14&#x27;</span>: <span class="string">&#x27;Zebrasoma scopas&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;fish_15&#x27;</span>: <span class="string">&#x27;Hemigymnus melapterus&#x27;</span>, <span class="string">&#x27;fish_16&#x27;</span>: <span class="string">&#x27;Lutjanus fulvus&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;fish_17&#x27;</span>: <span class="string">&#x27;Scolopsis bilineata&#x27;</span>, <span class="string">&#x27;fish_18&#x27;</span>: <span class="string">&#x27;Scaridae&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;fish_19&#x27;</span>: <span class="string">&#x27;Pempheris vanicolensis&#x27;</span>, <span class="string">&#x27;fish_20&#x27;</span>: <span class="string">&#x27;Zanclus cornutus&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;fish_21&#x27;</span>: <span class="string">&#x27;Neoglyphidodon nigroris&#x27;</span>, <span class="string">&#x27;fish_22&#x27;</span>: <span class="string">&#x27;Balistapus undulatus&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;fish_23&#x27;</span>: <span class="string">&#x27;Siganus fuscescens&#x27;</span>&#125;</span><br><span class="line">    name_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> lab_dict.items():  <span class="comment"># 将鱼的类别代号与类别名关联起来</span></span><br><span class="line">        name_dict[key] = temp[val]</span><br><span class="line">    <span class="keyword">return</span> name_dict</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------ 4.1.准备预测数据 ------</span></span><br><span class="line">truth_lab = <span class="string">&quot;Dascyllus reticulatus&quot;</span>    <span class="comment"># 待预测图片的标签</span></span><br><span class="line">infer_path = <span class="string">&quot;./work/infer.jpg&quot;</span></span><br><span class="line">img = load_image(infer_path)           <span class="comment"># 预处理图片</span></span><br><span class="line">name_dict = match_labels(lab_dict)     <span class="comment"># 获取转换标签的字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 4.2.创建预测用Executor ------</span></span><br><span class="line">infer_exe = fluid.Executor(place)    <span class="comment"># 预测用Executor</span></span><br><span class="line">infer_scope = fluid.core.Scope()     <span class="comment"># Scope指定作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 4.3.读取模型并开始预测 ------</span></span><br><span class="line"><span class="comment"># scope_guard方法修改全局/默认作用域(scope)，运行时所有变量都将分配给新的scope</span></span><br><span class="line"><span class="keyword">with</span> fluid.scope_guard(infer_scope):</span><br><span class="line">    [infer_program,        <span class="comment"># 推理的program</span></span><br><span class="line">    feed_target_names,     <span class="comment"># 需要在推理函数提供数据的变量名列表</span></span><br><span class="line">    fetch_targets          <span class="comment"># 推断结果参数列表</span></span><br><span class="line">    ] = fluid.io.load_inference_model(model_save_dir, infer_exe)  <span class="comment"># 载入模型</span></span><br><span class="line"></span><br><span class="line">    result = infer_exe.run(program=infer_program,              <span class="comment"># 运行推测程序</span></span><br><span class="line">                           feed=&#123;feed_target_names[<span class="number">0</span>]: img&#125;,   <span class="comment"># 喂入要预测的图像</span></span><br><span class="line">                           fetch_list=fetch_targets)           <span class="comment"># 得到推测结果</span></span><br><span class="line">    infer_lab = np.argmax(result)   <span class="comment"># 返回数组result中的最大值的索引值</span></span><br><span class="line">    infer_lab = name_dict[<span class="built_in">str</span>(infer_lab)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;真实标签：%s，预测结果：%s&quot;</span> % (truth_lab, infer_lab))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">真实标签：Dascyllus reticulatus，预测结果：Dascyllus reticulatus</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b57558a54fe14a0fbd66b1056537bdbb.png#pic_center" alt=""></p><hr/><blockquote><h1>写在最后</h1><ul><li>如果您发现项目存在问题，或者如果您有更好的建议，欢迎在下方评论区中留言讨论~</li><li>这是本项目的链接：<a href="https://aistudio.baidu.com/aistudio/projectdetail/829907?shared=1">实验项目 - AI Studio</a>，点击<code>fork</code>可直接在AI Studio运行~</li><li>这是我的个人主页：<a href="https://aistudio.baidu.com/aistudio/personalcenter/thirdview/118633">个人主页 - AI Studio</a>，来AI Studio互粉吧，等你哦~</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【AlexNet】数字手势识别</title>
      <link href="/2021/02/12/%E3%80%90AlexNet%E3%80%91%E6%95%B0%E5%AD%97%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/"/>
      <url>/2021/02/12/%E3%80%90AlexNet%E3%80%91%E6%95%B0%E5%AD%97%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1>问题导入</h1><p>图像分类是根据图像的语义信息将不同类别图像区分开来，是计算机视觉中重要的基本问题。本实验将使用经典神经网络模型AlexNet预测手势图片所表示的数字。</p><hr/><h1>一、基本概念</h1><h2 id="1-动态图DyGraph">1. 动态图DyGraph</h2><p>（1）PaddlePaddle动态图：</p><blockquote><p>PaddlePaddle的 <strong>动态图DyGraph模式</strong> 是一个更加灵活易用的模式，是一种动态的图执行机制，可以立即执行结果，无需构建整个图。PaddlePaddle DyGraph可以提供：</p><ul><li>更加灵活便捷的代码组织结构：使用python的执行控制流程和面向对象的模型设计</li><li>更加便捷的调试功能：直接使用python的打印方法即时打印所需要的结果，从而检查正在运行的模型结果便于测试更改</li><li>和静态执行图通用的模型代码：同样的模型代码可以使用更加便捷的DyGraph调试，执行，同时也支持使用原有的静态图模式执行</li></ul></blockquote><p>（2）动态图机制的优点：</p><blockquote><p>动态图机制不同于以往的静态图，无需构建整个图就可以立即执行结果。这使得我们在编写代码以及调试代码时更加直观、方便，我们无需编写静态图框架，这省去了我们大量的时间成本。利用动态图机制，我们能够更加快捷、直观地构建我们的深度学习网络。</p></blockquote><p>本项目采用的是动态图机制，动态图机制的使用方法请参考：</p><ul><li><a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/1.6/user_guides/howto/dygraph/DyGraph.html">动态图机制-DyGraph - PaddlePaddle文档</a></li><li><a href="https://blog.csdn.net/PaddlePaddle/article/details/100059492">还不懂动态图吗？一文带你了解飞桨动态图 - CSDN</a></li></ul><h2 id="2-AlexNet模型">2. AlexNet模型</h2><p>本实验使用的模型是经典卷积神经网络模型——AlexNet。<br>AlexNet是2012年ImageNet竞赛冠军获得者Hinton和他的学生Alex Krizhevsky设计的，也是在那年之后，更多的更深的神经网络被提出，卷积神经网络乃至深度学习重新引起了广泛的关注。<br><img src="https://img-blog.csdnimg.cn/20210211135043276.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RYS19LZXZpbg==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20210211134009100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RYS19LZXZpbg==,size_16,color_FFFFFF,t_70" alt=""></p><hr/><h1>二、实验数据集</h1><p>本次实验使用的数据集是由土耳其一所中学制作，数据集由<code>Main</code>文件夹中的训练/测试数据集和<code>Infer</code>文件夹中的预测数据集组成，包含<code>0-9</code>共10种数字的手势图片，实验图片都是大小为100 * 100像素、RGB格式的图像。</p><blockquote><p>这是数据集的下载链接：<a href="https://aistudio.baidu.com/aistudio/datasetdetail/51418">手势识别数据集 - AI Studio</a></p></blockquote><hr/><h1>三、实验步骤</h1><p><img src="https://img-blog.csdnimg.cn/20210208110405937.png#pic_center" alt=""></p><h2 id="0-导入模块-4">0. 导入模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> cpu_count</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">from</span> paddle <span class="keyword">import</span> fluid</span><br><span class="line"><span class="keyword">from</span> paddle.fluid.dygraph <span class="keyword">import</span> Conv2D, Pool2D, Linear, Dropout</span><br></pre></td></tr></table></figure><h2 id="1-数据准备-2">1. 数据准备</h2><ul><li><strong>数据预处理</strong><br>训练/测试数据集包含0-9共九种数字手势，总共2073张图片，我们将取其中的90%作为训练集，剩下的10%作为测试集。数据预处理的流程如下：<br>（1）由于数据集中的数据是以压缩包的形式存放的，因此我们需要先解压数据压缩包。<br>（2）接着，我们需要按1:9比例划分测试集和训练集，分别生成包含数据地址的列表。<br>（3）然后，我们需要分别构建用于训练和测试的数据提供器，其中训练数据提供器是乱序、按批次提供数据的。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unzip_data</span>(<span class="params">target_path, path1, path2</span>):   <span class="comment"># 将原数据集解压至指定路径</span></span><br><span class="line">    SRC_PATH = <span class="string">&quot;Gestures.zip&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(path1) <span class="keyword">or</span> <span class="keyword">not</span> os.path.isdir(path2):</span><br><span class="line">        z = zipfile.ZipFile(SRC_PATH, <span class="string">&quot;r&quot;</span>)   <span class="comment"># 打开压缩文件，创建zip对象</span></span><br><span class="line">        z.extractall(path=target_path)       <span class="comment"># 解压zip文件至target_path</span></span><br><span class="line">        z.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数据集解压完成！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_reader</span>(<span class="params">data_list</span>):    <span class="comment"># 批量读取图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">data_mapper</span>(<span class="params">sample</span>):   <span class="comment"># 读取图片并对图片进行归一化处理</span></span><br><span class="line">        img, label = sample</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img).resize((<span class="number">224</span>, <span class="number">224</span>), Image.ANTIALIAS)   <span class="comment"># 缩放为224*224的高质量图像</span></span><br><span class="line">        img = np.array(img).astype(<span class="string">&quot;float32&quot;</span>)        <span class="comment"># 把图像变成一个numpy数组以匹配数据馈送格式</span></span><br><span class="line">        img = img.transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))  <span class="comment"># 将图像矩阵由“rgb,rgb,rbg...”转置为“rr...,gg...,bb...”</span></span><br><span class="line">        img = img / <span class="number">255.0</span>               <span class="comment"># 将图像数据归一化</span></span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reader</span>():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> data_list:</span><br><span class="line">            img_path, label = data[<span class="number">0</span>], data[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">yield</span> img_path, <span class="built_in">int</span>(label)   <span class="comment"># 返回图像地址和标签（for循环结束前程序不会停止）</span></span><br><span class="line">    <span class="keyword">return</span> paddle.reader.xmap_readers(data_mapper, reader, cpu_count(), <span class="number">512</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------ 1.1.划分数据集 ------</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span>    <span class="comment"># 数据批次大小</span></span><br><span class="line">CLASS_DIM = <span class="number">10</span>     <span class="comment"># 手势的种类数</span></span><br><span class="line">DATA_PATH = <span class="string">&#x27;./data/Main&#x27;</span>        <span class="comment"># 训练测试集路径</span></span><br><span class="line">INFER_PATH = <span class="string">&#x27;./data/Infer&#x27;</span>      <span class="comment"># 预测数据集路径</span></span><br><span class="line">train_list, test_list = [], []   <span class="comment"># 暂存训练集路径和测试集路径</span></span><br><span class="line">unzip_data(<span class="string">&#x27;./data&#x27;</span>, DATA_PATH, INFER_PATH)    <span class="comment"># 解压数据集</span></span><br><span class="line">file_folders = os.listdir(DATA_PATH)   <span class="comment"># DATA_PATH路径下的文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> folder <span class="keyword">in</span> file_folders:</span><br><span class="line">    images = os.listdir(os.path.join(DATA_PATH, folder))</span><br><span class="line">    <span class="keyword">for</span> idx, img <span class="keyword">in</span> <span class="built_in">enumerate</span>(images):</span><br><span class="line">        img_path = os.path.join(DATA_PATH, folder, img)</span><br><span class="line">        value = [img_path, folder]       <span class="comment"># 记录图片链接及其标签代号</span></span><br><span class="line">        <span class="keyword">if</span> idx % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            test_list.append(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            train_list.append(value)</span><br><span class="line"></span><br><span class="line">random.shuffle(train_list)    <span class="comment"># 打乱训练集数据</span></span><br><span class="line">random.shuffle(test_list)     <span class="comment"># 打乱测试集数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 1.2.训练数据集准备 ------</span></span><br><span class="line">BUF_SIZE, BATCH_SIZE = <span class="number">512</span>, <span class="number">32</span></span><br><span class="line">train_reader = paddle.batch(</span><br><span class="line">    paddle.reader.shuffle(</span><br><span class="line">        data_reader(train_list), buf_size=BUF_SIZE</span><br><span class="line">    ),  <span class="comment"># 每次缓存BUF_SIZE个训练数据项，并打乱</span></span><br><span class="line">    batch_size=BATCH_SIZE</span><br><span class="line">)   <span class="comment"># 按批次读取乱序后的训练数据，批次大小为BATCH_SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 1.3.测试数据集准备 ------</span></span><br><span class="line">test_reader = paddle.batch(</span><br><span class="line">    data_reader(test_list), batch_size=BATCH_SIZE</span><br><span class="line">)   <span class="comment"># 按批次读取测试数据，批次大小为BATCH_SIZE</span></span><br></pre></td></tr></table></figure><h2 id="2-网络配置">2. 网络配置</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AlexNet</span>(fluid.dygraph.Layer):  <span class="comment"># AlexNet神经网络类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, class_dim</span>):</span><br><span class="line">        <span class="built_in">super</span>(AlexNet, self).__init__()</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;   函数参数含义：</span></span><br><span class="line"><span class="string">        Conv2D(通道数,卷积核数,卷积核大小,卷积步长,padding填充长度,act激活函数)</span></span><br><span class="line"><span class="string">        Pool2D(池化核大小,池化步长,池化类型)</span></span><br><span class="line"><span class="string">        Linear(输入大小,输出大小,act激活函数)</span></span><br><span class="line"><span class="string">        Dropout(dropout发生的概率)</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.conv1 = Conv2D(<span class="number">3</span>, <span class="number">96</span>, <span class="number">11</span>, stride=<span class="number">4</span>, padding=<span class="number">2</span>, act=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.pool1 = Pool2D(pool_size=<span class="number">3</span>, pool_stride=<span class="number">2</span>, pool_type=<span class="string">&#x27;max&#x27;</span>)</span><br><span class="line">        self.conv2 = Conv2D(<span class="number">96</span>, <span class="number">256</span>, <span class="number">5</span>, stride=<span class="number">1</span>, padding=<span class="number">2</span>, act=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.pool2 = Pool2D(pool_size=<span class="number">3</span>, pool_stride=<span class="number">2</span>, pool_type=<span class="string">&#x27;max&#x27;</span>)</span><br><span class="line">        self.conv3 = Conv2D(<span class="number">256</span>, <span class="number">384</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>, act=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.conv4 = Conv2D(<span class="number">384</span>, <span class="number">384</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>, act=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.conv5 = Conv2D(<span class="number">384</span>, <span class="number">256</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>, act=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.pool3 = Pool2D(pool_size=<span class="number">3</span>, pool_stride=<span class="number">2</span>, pool_type=<span class="string">&#x27;max&#x27;</span>)</span><br><span class="line">        self.fc1 = Linear(<span class="number">256</span> * <span class="number">6</span> * <span class="number">6</span>, <span class="number">4096</span>, act=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.drop1 = Dropout(p=<span class="number">0.5</span>)</span><br><span class="line">        self.fc2 = Linear(<span class="number">4096</span>, <span class="number">4096</span>, act=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.drop2 = Dropout(p=<span class="number">0.5</span>)</span><br><span class="line">        self.fc3 = Linear(<span class="number">4096</span>, class_dim, act=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):  <span class="comment"># 前向传播参数，连接各层组成神经网络</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.pool1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = self.pool2(x)</span><br><span class="line">        x = self.conv3(x)</span><br><span class="line">        x = self.conv4(x)</span><br><span class="line">        x = self.conv5(x)</span><br><span class="line">        x = self.pool3(x)</span><br><span class="line">        x = fluid.layers.reshape(x, [-<span class="number">1</span>, <span class="number">256</span>*<span class="number">6</span>*<span class="number">6</span>])</span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.drop1(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        x = self.drop2(x)</span><br><span class="line">        y = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h2 id="3-模型训练-2">3. 模型训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">EPOCH_NUM, train_iter = <span class="number">9</span>, <span class="number">0</span></span><br><span class="line">train_iters, train_costs, train_accs = [], [], []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_train_progress</span>(<span class="params">iters, loss, accs</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw_training_loss</span>():    <span class="comment"># 绘制训练误差图像</span></span><br><span class="line">        plt.subplot(<span class="number">121</span>)</span><br><span class="line">        plt.title(<span class="string">&quot;Training Loss&quot;</span>, fontsize=<span class="number">25</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&quot;iter&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&quot;loss&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">        plt.plot(iters, loss, color=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">        plt.grid()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw_training_acc</span>():     <span class="comment"># 绘制训练准确率图像</span></span><br><span class="line">        plt.subplot(<span class="number">122</span>)</span><br><span class="line">        plt.title(<span class="string">&quot;Training Accuracy&quot;</span>, fontsize=<span class="number">25</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&quot;iter&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&quot;accuracy&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">        plt.plot(iters, accs, color=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">        plt.grid()</span><br><span class="line">    </span><br><span class="line">    plt.figure(figsize=[<span class="number">15</span>, <span class="number">5</span>])</span><br><span class="line">    draw_training_loss()</span><br><span class="line">    draw_training_acc()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():   <span class="comment"># 用动态图进行训练</span></span><br><span class="line">    model = AlexNet(CLASS_DIM)  <span class="comment"># 模型实例化</span></span><br><span class="line">    model.train()               <span class="comment"># 开启训练模式</span></span><br><span class="line">    opt = fluid.optimizer.Adam(</span><br><span class="line">        learning_rate=fluid.dygraph.NaturalExpDecay(</span><br><span class="line">            learning_rate=<span class="number">1e-4</span>,   <span class="comment"># 初始学习率</span></span><br><span class="line">            decay_steps=<span class="number">128</span>,      <span class="comment"># 学习率衰减步长</span></span><br><span class="line">            decay_rate=<span class="number">0.3</span>        <span class="comment"># 学习率衰减率</span></span><br><span class="line">        ),  <span class="comment"># 在学习率上使用自然指数衰减</span></span><br><span class="line">        parameter_list=model.parameters()</span><br><span class="line">    )   <span class="comment"># 定义优化器，采用Adam优化算法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pass_id <span class="keyword">in</span> <span class="built_in">range</span>(EPOCH_NUM):   <span class="comment"># 训练EPOCH_NUM轮</span></span><br><span class="line">        <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_reader()):</span><br><span class="line">            <span class="comment"># 将数据集中的图像、标签数据转化为numpy.array格式的数据：</span></span><br><span class="line">            image = np.array([x[<span class="number">0</span>].reshape(<span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>) <span class="keyword">for</span> x <span class="keyword">in</span> data], np.float32)</span><br><span class="line">            label = np.array([x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> data]).astype(<span class="string">&quot;int64&quot;</span>)[:, np.newaxis]</span><br><span class="line">            <span class="comment"># 将数据转化为fluid.dygraph能够接受的Variable类型的对象：</span></span><br><span class="line">            image = fluid.dygraph.to_variable(image)</span><br><span class="line">            label = fluid.dygraph.to_variable(label)</span><br><span class="line"></span><br><span class="line">            predict = model(image)   <span class="comment"># 训练模型</span></span><br><span class="line">            train_loss = fluid.layers.cross_entropy(predict, label)   <span class="comment"># 计算交叉熵</span></span><br><span class="line">            avg_loss = fluid.layers.mean(train_loss)                  <span class="comment"># 求平均损失值</span></span><br><span class="line">            train_acc = fluid.layers.accuracy(predict, label)         <span class="comment"># 计算准确率</span></span><br><span class="line"></span><br><span class="line">            train_iter += BATCH_SIZE</span><br><span class="line">            train_iters.append(train_iter)             <span class="comment"># 迭代次数</span></span><br><span class="line">            train_costs.append(avg_loss.numpy()[<span class="number">0</span>])    <span class="comment"># 训练误差</span></span><br><span class="line">            train_accs.append(train_acc.numpy()[<span class="number">0</span>])    <span class="comment"># 训练准确率</span></span><br><span class="line">            <span class="keyword">if</span> batch_id != <span class="number">0</span> <span class="keyword">and</span> batch_id % <span class="number">50</span> == <span class="number">0</span>:   <span class="comment"># 输出训练信息</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Pass：%2d；Batch：%2d；Loss：%.6f；Accuracy：%.4f&quot;</span> %</span><br><span class="line">                        (pass_id, batch_id, train_costs[-<span class="number">1</span>], train_accs[-<span class="number">1</span>]))</span><br><span class="line">            </span><br><span class="line">            avg_loss.backward()       <span class="comment"># 进行反向传播操作</span></span><br><span class="line">            opt.minimize(avg_loss)    <span class="comment"># 调用优化器中的minimize()方法更新参数</span></span><br><span class="line">            model.clear_gradients()   <span class="comment"># 每轮参数更新后需重置梯度，以保证下轮的正确性</span></span><br><span class="line">    </span><br><span class="line">    draw_train_progress(train_iters, train_costs, train_accs)  <span class="comment"># 绘制训练过程</span></span><br><span class="line">    fluid.save_dygraph(model.state_dict(), <span class="string">&quot;AlexNet&quot;</span>)  <span class="comment"># 保存训练好的模型</span></span><br></pre></td></tr></table></figure><p>模型训练结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass： 0；Batch：50；Loss：2.262135；Accuracy：0.1875</span><br><span class="line">Pass： 1；Batch：50；Loss：0.803589；Accuracy：0.7188</span><br><span class="line">Pass： 2；Batch：50；Loss：0.597640；Accuracy：0.7812</span><br><span class="line">Pass： 3；Batch：50；Loss：0.457550；Accuracy：0.8438</span><br><span class="line">Pass： 4；Batch：50；Loss：0.340216；Accuracy：0.8750</span><br><span class="line">Pass： 5；Batch：50；Loss：0.106287；Accuracy：0.9688</span><br><span class="line">Pass： 6；Batch：50；Loss：0.100151；Accuracy：0.9688</span><br><span class="line">Pass： 7；Batch：50；Loss：0.022734；Accuracy：1.0000</span><br><span class="line">Pass： 8；Batch：50；Loss：0.009387；Accuracy：1.0000</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210211150705725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RYS19LZXZpbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="4-模型评估-2">4. 模型评估</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():   <span class="comment"># 用动态图进行模型评估</span></span><br><span class="line">    test_costs, test_accs = [], []</span><br><span class="line">    model = AlexNet(CLASS_DIM)  <span class="comment"># 模型实例化</span></span><br><span class="line">    model_dict, _ = fluid.load_dygraph(<span class="string">&quot;AlexNet&quot;</span>)   <span class="comment"># 加载模型参数</span></span><br><span class="line">    model.load_dict(model_dict)             <span class="comment"># 将参数载入到新模型中</span></span><br><span class="line">    model.<span class="built_in">eval</span>()           <span class="comment"># 开启评估模式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_reader()):</span><br><span class="line">        <span class="comment"># 将数据集中的图像、标签数据转化为特定numpy数组格式的数据：</span></span><br><span class="line">        image = np.array([x[<span class="number">0</span>].reshape(<span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>) <span class="keyword">for</span> x <span class="keyword">in</span> data], np.float32)</span><br><span class="line">        label = np.array([x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> data]).astype(<span class="string">&quot;int64&quot;</span>)[:, np.newaxis]</span><br><span class="line">        <span class="comment"># 将数据转化为fluid.dygraph能够接受的Variable类型的对象：</span></span><br><span class="line">        image = fluid.dygraph.to_variable(image)</span><br><span class="line">        label = fluid.dygraph.to_variable(label)</span><br><span class="line"></span><br><span class="line">        predict = model(image)       <span class="comment"># 模型测试</span></span><br><span class="line">        test_loss = fluid.layers.cross_entropy(predict, label)   <span class="comment"># 计算交叉熵</span></span><br><span class="line">        avg_loss = fluid.layers.mean(test_loss)                  <span class="comment"># 求平均损失值</span></span><br><span class="line">        test_costs.append(avg_loss.numpy()[<span class="number">0</span>])</span><br><span class="line">        test_acc = fluid.layers.accuracy(predict, label)         <span class="comment"># 计算准确率</span></span><br><span class="line">        test_accs.append(test_acc.numpy()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    test_loss = np.mean(test_costs)    <span class="comment"># 计算平均损失值</span></span><br><span class="line">    test_acc = np.mean(test_accs)      <span class="comment"># 计算平均准确率</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Eval \t Avg_Loss：%.5f；Accuracy：%.5f&quot;</span> % (test_loss, test_acc))</span><br></pre></td></tr></table></figure><p>模型评估结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eval  Avg_Loss：0.14303；Accuracy：0.96627</span><br></pre></td></tr></table></figure><h2 id="5-模型预测-2">5. 模型预测</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_image</span>(<span class="params">path</span>):          <span class="comment"># 图片预处理</span></span><br><span class="line">    <span class="comment"># (1) 打开并展示图像：</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(path)   <span class="comment"># 打开图像</span></span><br><span class="line">    display(img)             <span class="comment"># 显示图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># (2) 格式化图像：</span></span><br><span class="line">    img = img.resize((<span class="number">224</span>, <span class="number">224</span>), Image.ANTIALIAS)</span><br><span class="line">    img = np.array(img).astype(<span class="string">&quot;float32&quot;</span>)  <span class="comment"># 把图像变成一个numpy数组以匹配数据馈送格式</span></span><br><span class="line">    img = img.transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    img = img / <span class="number">255.0</span>    <span class="comment"># 将数据进行归一化处理</span></span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():  <span class="comment"># 用动态图进行模型预测</span></span><br><span class="line">    model = AlexNet(CLASS_DIM)  <span class="comment"># 模型实例化</span></span><br><span class="line">    model_dict, _ = fluid.load_dygraph(<span class="string">&quot;AlexNet&quot;</span>)   <span class="comment"># 加载模型参数</span></span><br><span class="line">    model.load_dict(model_dict)              <span class="comment"># 将参数载入到新模型中</span></span><br><span class="line">    model.<span class="built_in">eval</span>()           <span class="comment"># 开启评估模式</span></span><br><span class="line"></span><br><span class="line">    truth_lab = random.randint(<span class="number">0</span>, <span class="number">9</span>)                 <span class="comment"># 预测图片的真实标签</span></span><br><span class="line">    infer_path = INFER_PATH + <span class="string">&#x27;/infer_%d.JPG&#x27;</span>        <span class="comment"># 预测图片的路径</span></span><br><span class="line">    infer_img = load_image(infer_path % truth_lab)   <span class="comment"># 获取预测图片</span></span><br><span class="line">    infer_img = np.array(infer_img).astype(<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">    infer_img = infer_img[np.newaxis, :, :, :]</span><br><span class="line">    <span class="comment"># 将数据转化为fluid.dygraph能够接受的Variable类型的对象：</span></span><br><span class="line">    infer_img = fluid.dygraph.to_variable(infer_img)</span><br><span class="line"></span><br><span class="line">    result = model(infer_img)              <span class="comment"># 模型预测，返回长度为10的概率数组</span></span><br><span class="line">    infer_lab = np.argmax(result.numpy())  <span class="comment"># 返回数组result中的最大值的索引值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n该图片的真实标签为%d，模型预测结果为%d&quot;</span> % (truth_lab, infer_lab))</span><br></pre></td></tr></table></figure><p>模型预测结果如下：<br><img src="https://img-blog.csdnimg.cn/20210211135246733.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该图片的真实标签为7，模型预测结果为7</span><br></pre></td></tr></table></figure><hr/><blockquote><h1>写在最后</h1><ul><li>如果您发现项目存在问题，或者如果您有更好的建议，欢迎在下方评论区中留言讨论~</li><li>这是本项目的链接：<a href="https://aistudio.baidu.com/aistudio/projectdetail/753862?shared=1">实验项目 - AI Studio</a>，点击<code>fork</code>可直接在AI Studio运行~</li><li>这是我的个人主页：<a href="https://aistudio.baidu.com/aistudio/personalcenter/thirdview/118633">个人主页 - AI Studio</a>，来AI Studio互粉吧，等你哦~</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeNet5】简单车牌识别</title>
      <link href="/2020/09/04/%E3%80%90LeNet5%E3%80%91%E7%AE%80%E5%8D%95%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB/"/>
      <url>/2020/09/04/%E3%80%90LeNet5%E3%80%91%E7%AE%80%E5%8D%95%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1>问题导入</h1><p>本次实践是一个多分类任务，需要将照片中的每个字符分别进行识别，我们将借助CV2模块完成对车牌图像逐字符划分，然后训练卷积神经网络模型LeNet5完成对车牌的识别。<br><img src="https://img-blog.csdnimg.cn/08f8a5d843a043e3abcede2536b4b721.jpeg#pic_center" alt=""></p><hr/><h1>一、基本概念</h1><h2 id="1-动态图DyGraph-2">1. 动态图DyGraph</h2><p>（1）PaddlePaddle动态图：</p><blockquote><p>PaddlePaddle的 <strong>动态图DyGraph模式</strong> 是一个更加灵活易用的模式，是一种动态的图执行机制，可以立即执行结果，无需构建整个图。PaddlePaddle DyGraph可以提供：</p><ul><li>更加灵活便捷的代码组织结构：使用python的执行控制流程和面向对象的模型设计</li><li>更加便捷的调试功能：直接使用python的打印方法即时打印所需要的结果，从而检查正在运行的模型结果便于测试更改</li><li>和静态执行图通用的模型代码：同样的模型代码可以使用更加便捷的DyGraph调试，执行，同时也支持使用原有的静态图模式执行</li></ul></blockquote><p>（2）动态图机制的优点：</p><blockquote><p>动态图机制不同于以往的静态图，无需构建整个图就可以立即执行结果。这使得我们在编写代码以及调试代码时更加直观、方便，我们无需编写静态图框架，这省去了我们大量的时间成本。利用动态图机制，我们能够更加快捷、直观地构建我们的深度学习网络。</p></blockquote><p>本项目采用的是动态图机制，动态图机制的使用方法请参考：</p><ul><li><a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/1.6/user_guides/howto/dygraph/DyGraph.html">动态图机制-DyGraph - PaddlePaddle文档</a></li><li><a href="https://blog.csdn.net/PaddlePaddle/article/details/100059492">还不懂动态图吗？一文带你了解飞桨动态图 - CSDN</a></li></ul><h2 id="2-LeNet5模型">2. LeNet5模型</h2><p><strong>LeNet-5</strong> 源自<strong>Yann LeCun</strong>的论文 “Gradient-Based Learning Applied to Document Recognition”，是一种用于手写体字符识别的、结构简单、非常高效的卷积神经网络。<br><img src="https://img-blog.csdnimg.cn/img_convert/0e0ac55b2236b69467b670d919b8bb34.png#pic_center" alt=""></p><hr/><h1>二、实验数据集</h1><p>实验数据集中有65个文件夹，包含数字 (0-9)、大写字母 (A-Z) 以及各省简称，每个文件夹存放一类图片，所有的图片均为120 * 120像素的灰度图像。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/14960b16959204c3e2b473410a46dda1.png#pic_center" alt=""></p><blockquote><p>这是数据集的下载链接：<a href="https://aistudio.baidu.com/aistudio/datasetdetail/23617">车牌识别数据集 - AI Studio</a></p></blockquote><hr/><h1>三、实验步骤</h1><p><img src="https://img-blog.csdnimg.cn/20210208110405937.png#pic_center" alt=""></p><h2 id="0-导入模块-5">0. 导入模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2       <span class="comment"># 在本项目中，它主要用来分割图像</span></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> cpu_count</span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">from</span> paddle <span class="keyword">import</span> fluid</span><br><span class="line"><span class="keyword">from</span> paddle.fluid.dygraph <span class="keyword">import</span> Conv2D, Pool2D, Linear</span><br></pre></td></tr></table></figure><h2 id="1-数据准备-3">1. 数据准备</h2><ul><li><strong>数据预处理</strong><br>训练/测试数据集包含车牌中出现的所有字符的图片，本次实验将取其中的90%作为训练集，剩下的10%作为测试集。数据预处理的流程如下：<br>（1）由于数据集中的数据是以压缩包的形式存放的，因此我们需要先解压数据压缩包。<br>（2）接着，我们需要按1:9比例划分测试集和训练集，分别生成包含数据地址的两个列表。<br>（3）然后，我们需要分别构建用于训练和测试的数据提供器，其中训练数据提供器是乱序、按批次提供数据的。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unzip_data</span>(<span class="params">target_path</span>):      <span class="comment"># 将原数据集解压至指定路径</span></span><br><span class="line">    SRC_PATH = <span class="string">&quot;characterData.zip&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(target_path):</span><br><span class="line">        z = zipfile.ZipFile(SRC_PATH, <span class="string">&#x27;r&#x27;</span>)   <span class="comment"># 打开Zip文件，创建Zip对象</span></span><br><span class="line">        z.extractall(path=target_path)       <span class="comment"># 解压Zip文件至target_path</span></span><br><span class="line">        shutil.rmtree(<span class="string">&quot;./data/dataset/__MACOSX&quot;</span>)     <span class="comment"># 删除无关文件</span></span><br><span class="line">        z.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数据集解压完成！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_mapper</span>(<span class="params">sample</span>):    <span class="comment"># 对图片进行预处理</span></span><br><span class="line">    img_path, label = sample</span><br><span class="line">    img = Image.<span class="built_in">open</span>(img_path).convert(<span class="string">&quot;L&quot;</span>)  <span class="comment"># 将图像打开并转为灰度图</span></span><br><span class="line">    img = img.resize((<span class="number">32</span>, <span class="number">32</span>), Image.ANTIALIAS)</span><br><span class="line">    img = np.array(img).reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)\</span><br><span class="line">        .astype(<span class="string">&#x27;float32&#x27;</span>)          <span class="comment"># 把图像变成numpy数组以匹配数据馈送格式</span></span><br><span class="line">    img = img / <span class="number">255.0</span> * <span class="number">2.0</span> - <span class="number">1.0</span>   <span class="comment"># 将数据归一化到[-1, 1]之间</span></span><br><span class="line">    <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_reader</span>(<span class="params">data_list</span>):  <span class="comment"># 按批量读取图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reader</span>():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> data_list:</span><br><span class="line">            img_path, label = data[<span class="number">0</span>], data[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">yield</span> img_path, <span class="built_in">int</span>(label)  <span class="comment"># 返回图像路径和标签（for循环结束前程序不会停止）</span></span><br><span class="line">    <span class="keyword">return</span> paddle.reader.xmap_readers(data_mapper, reader, cpu_count(), <span class="number">1024</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------ 1.1.解压数据集 ------</span></span><br><span class="line">data_path = <span class="string">&quot;./data/dataset&quot;</span>             <span class="comment"># 数据集路径</span></span><br><span class="line">unzip_data(data_path)                    <span class="comment"># 解压原数据集至指定路径</span></span><br><span class="line">file_folders = os.listdir(data_path)     <span class="comment"># data_path路径下的文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 1.2.划分数据集 ------</span></span><br><span class="line">train_list, test_list = [], []           <span class="comment"># 存放训练集和数据集的位置以及类别</span></span><br><span class="line">char_num, label_dict = <span class="number">0</span>, &#123;&#125;             <span class="comment"># 方便字符在整型和字符型之间转换</span></span><br><span class="line"><span class="keyword">for</span> folder <span class="keyword">in</span> file_folders:</span><br><span class="line">    label_dict[<span class="built_in">str</span>(char_num)] = folder  <span class="comment"># 记录标签和代号的对应关系</span></span><br><span class="line">    images = os.listdir(os.path.join(data_path, folder))</span><br><span class="line">    <span class="keyword">for</span> idx, img <span class="keyword">in</span> <span class="built_in">enumerate</span>(images):</span><br><span class="line">        img_path = os.path.join(data_path, folder, img)</span><br><span class="line">        value = [img_path, char_num]</span><br><span class="line">        <span class="keyword">if</span> idx % <span class="number">10</span> == <span class="number">0</span>:      <span class="comment"># 按照1:9的比例划分数据集</span></span><br><span class="line">            test_list.append(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            train_list.append(value)</span><br><span class="line">    char_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">random.shuffle(train_list)    <span class="comment"># 打乱训练集数据</span></span><br><span class="line">random.shuffle(test_list)     <span class="comment"># 打乱测试集数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 1.3.准备训练数据集 ------</span></span><br><span class="line">BUF_SIZE, BATCH_SIZE = <span class="number">512</span>, <span class="number">128</span></span><br><span class="line">train_reader = paddle.batch(</span><br><span class="line">    paddle.reader.shuffle(</span><br><span class="line">        data_reader(train_list), buf_size=BUF_SIZE</span><br><span class="line">    ),  <span class="comment"># 每次缓存BUF_SIZE个训练数据项，并打乱</span></span><br><span class="line">    batch_size=BATCH_SIZE</span><br><span class="line">)   <span class="comment"># 按批次读取乱序后的训练数据，批次大小为BATCH_SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 1.4.准备测试数据集 ------</span></span><br><span class="line">test_reader = paddle.batch(</span><br><span class="line">    data_reader(test_list), batch_size=BATCH_SIZE</span><br><span class="line">)   <span class="comment"># 按批次读取测试数据，批次大小为BATCH_SIZE</span></span><br></pre></td></tr></table></figure><h2 id="2-网络配置-2">2. 网络配置</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLeNet</span>(fluid.dygraph.Layer):     <span class="comment"># 构建CNN模型类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyLeNet, self).__init__()</span><br><span class="line">        self.c1 = Conv2D(               <span class="comment"># 定义一个卷积层</span></span><br><span class="line">            num_channels=<span class="number">1</span>,   <span class="comment"># 输入的通道数</span></span><br><span class="line">            num_filters=<span class="number">6</span>,    <span class="comment"># 卷积核的个数</span></span><br><span class="line">            filter_size=<span class="number">5</span>,    <span class="comment"># 卷积核的大小</span></span><br><span class="line">            stride=<span class="number">1</span>          <span class="comment"># 卷积层的步长</span></span><br><span class="line">        )</span><br><span class="line">        self.s2 = Pool2D(               <span class="comment"># 定义一个池化层</span></span><br><span class="line">            pool_size=<span class="number">2</span>,      <span class="comment"># 池化核的大小</span></span><br><span class="line">            pool_type=<span class="string">&quot;max&quot;</span>,  <span class="comment"># 池化类型：“max” or “avg”</span></span><br><span class="line">            pool_stride=<span class="number">2</span>     <span class="comment"># 池化层的步长</span></span><br><span class="line">        )</span><br><span class="line">        self.c3 = Conv2D(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">        self.s4 = Pool2D(<span class="number">2</span>, <span class="string">&quot;max&quot;</span>, <span class="number">2</span>)</span><br><span class="line">        self.c5 = Conv2D(<span class="number">16</span>, <span class="number">120</span>, <span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">        self.f6 = Linear(<span class="number">120</span>, <span class="number">84</span>, act=<span class="string">&quot;relu&quot;</span>)</span><br><span class="line">        self.output = Linear(<span class="number">84</span>, char_num, act=<span class="string">&quot;softmax&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        x = self.c1(<span class="built_in">input</span>)   <span class="comment"># 输出维度为28*28*6</span></span><br><span class="line">        x = self.s2(x)       <span class="comment"># 输出维度为14*14*6</span></span><br><span class="line">        x = self.c3(x)       <span class="comment"># 输出维度为10*10*6</span></span><br><span class="line">        x = self.s4(x)       <span class="comment"># 输出维度为5*5*16</span></span><br><span class="line">        x = self.c5(x)       <span class="comment"># 输出维度为120</span></span><br><span class="line">        x = fluid.layers.reshape(x, shape=[-<span class="number">1</span>, <span class="number">120</span>])</span><br><span class="line">        x = self.f6(x)       <span class="comment"># 输出维度为84</span></span><br><span class="line">        y = self.output(x)   <span class="comment"># 输出维度为10</span></span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h2 id="3-模型训练-3">3. 模型训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">EPOCH_NUM, train_iter = <span class="number">25</span>, <span class="number">0</span></span><br><span class="line">train_iters, train_costs, train_accs = [], [], []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_training_loss</span>(<span class="params">iters, costs</span>):    <span class="comment"># 绘制训练误差图像</span></span><br><span class="line">    plt.figure(figsize=[<span class="number">10</span>, <span class="number">5</span>])</span><br><span class="line">    plt.title(<span class="string">&quot;Training Loss&quot;</span>, fontsize=<span class="number">25</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;iter&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;loss&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">    plt.plot(iters, costs, color=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_training_acc</span>(<span class="params">iters, accs</span>):     <span class="comment"># 绘制训练准确率图像</span></span><br><span class="line">    plt.figure(figsize=[<span class="number">10</span>, <span class="number">5</span>])</span><br><span class="line">    plt.title(<span class="string">&quot;Training Accuracy&quot;</span>, fontsize=<span class="number">25</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;iter&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;accuracy&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">    plt.plot(iters, accs, color=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():      <span class="comment"># 使用动态图进行模型训练</span></span><br><span class="line">    model = MyLeNet()    <span class="comment"># 模型实例化</span></span><br><span class="line">    model.train()        <span class="comment"># 开启训练模式</span></span><br><span class="line">    opt = fluid.optimizer.AdamOptimizer(</span><br><span class="line">        learning_rate=fluid.dygraph.ExponentialDecay(</span><br><span class="line">            learning_rate=<span class="number">0.001</span>,  <span class="comment"># 初始学习率</span></span><br><span class="line">            decay_steps=<span class="number">750</span>,      <span class="comment"># 学习率衰减步长</span></span><br><span class="line">            decay_rate=<span class="number">0.25</span>,      <span class="comment"># 学习率衰减率</span></span><br><span class="line">            staircase=<span class="literal">True</span>        <span class="comment"># 每decay_steps步学习率衰减为原来的decay_rate</span></span><br><span class="line">        ),  <span class="comment"># 学习率呈现指数衰减</span></span><br><span class="line">        parameter_list=model.parameters()</span><br><span class="line">    )   <span class="comment"># 定义优化器，采用Adam优化算法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pass_id <span class="keyword">in</span> <span class="built_in">range</span>(EPOCH_NUM):    <span class="comment"># 训练EPOCH_NUM轮</span></span><br><span class="line">        <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_reader()):</span><br><span class="line">            <span class="comment"># 将数据集中的图像、标签数据转化为numpy.array格式的数据：</span></span><br><span class="line">            image = np.array([x[<span class="number">0</span>].reshape(<span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>) <span class="keyword">for</span> x <span class="keyword">in</span> data], np.float32)</span><br><span class="line">            label = np.array([x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> data]).astype(<span class="string">&quot;int64&quot;</span>)</span><br><span class="line">            label = label[:, np.newaxis]    <span class="comment"># 在label中增加一维维度</span></span><br><span class="line">            <span class="comment"># 将数据转化为fluid.dygraph能够接受的Variable类型的对象：</span></span><br><span class="line">            image = fluid.dygraph.to_variable(image)</span><br><span class="line">            label = fluid.dygraph.to_variable(label)</span><br><span class="line"></span><br><span class="line">            predict = model(image)   <span class="comment"># 训练模型</span></span><br><span class="line">            train_loss = fluid.layers.cross_entropy(predict, label)  <span class="comment"># 计算交叉熵</span></span><br><span class="line">            avg_loss = fluid.layers.mean(train_loss)                 <span class="comment"># 求平均损失值</span></span><br><span class="line">            train_acc = fluid.layers.accuracy(predict, label)        <span class="comment"># 计算准确率</span></span><br><span class="line"></span><br><span class="line">            train_iter += BATCH_SIZE</span><br><span class="line">            train_iters.append(train_iter)            <span class="comment"># 迭代次数</span></span><br><span class="line">            train_costs.append(avg_loss.numpy()[<span class="number">0</span>])   <span class="comment"># 训练误差</span></span><br><span class="line">            train_accs.append(train_acc.numpy()[<span class="number">0</span>])   <span class="comment"># 训练准确率</span></span><br><span class="line">            <span class="keyword">if</span> batch_id != <span class="number">0</span> <span class="keyword">and</span> batch_id % <span class="number">110</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Pass：%3d；Batch：%2d；Loss：%.5f；Accuracy：%.5f&quot;</span> %</span><br><span class="line">                        (pass_id, batch_id, train_costs[-<span class="number">1</span>], train_accs[-<span class="number">1</span>]))</span><br><span class="line">            </span><br><span class="line">            avg_loss.backward()      <span class="comment"># 执行反向传播算法</span></span><br><span class="line">            opt.minimize(avg_loss)   <span class="comment"># 调用优化器中的minimize()方法更新参数</span></span><br><span class="line">            model.clear_gradients()  <span class="comment"># 每轮参数更新后需重置梯度，以确保下轮的正确性</span></span><br><span class="line">        </span><br><span class="line">    draw_training_loss(train_iters, train_costs)        <span class="comment"># 绘制训练损失值图像</span></span><br><span class="line">    draw_training_acc(train_iters, train_accs)          <span class="comment"># 绘制训练准确率图像</span></span><br><span class="line">    fluid.save_dygraph(model.state_dict(), <span class="string">&quot;MyLeNet&quot;</span>)   <span class="comment"># 保存训练好的模型</span></span><br></pre></td></tr></table></figure><p>模型训练结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass：  0；Batch：110；Loss：0.34848；Accuracy：0.89844</span><br><span class="line">Pass：  1；Batch：110；Loss：0.13844；Accuracy：0.96875</span><br><span class="line">Pass：  2；Batch：110；Loss：0.08487；Accuracy：0.96875</span><br><span class="line">Pass：  3；Batch：110；Loss：0.07444；Accuracy：0.98438</span><br><span class="line">Pass：  4；Batch：110；Loss：0.05620；Accuracy：0.99219</span><br><span class="line">Pass：  5；Batch：110；Loss：0.07430；Accuracy：0.98438</span><br><span class="line">Pass：  6；Batch：110；Loss：0.03116；Accuracy：0.99219</span><br><span class="line">Pass：  7；Batch：110；Loss：0.01135；Accuracy：1.00000</span><br><span class="line">Pass：  8；Batch：110；Loss：0.00264；Accuracy：1.00000</span><br><span class="line">Pass：  9；Batch：110；Loss：0.00669；Accuracy：1.00000</span><br><span class="line">Pass： 10；Batch：110；Loss：0.00272；Accuracy：1.00000</span><br><span class="line">Pass： 11；Batch：110；Loss：0.00407；Accuracy：1.00000</span><br><span class="line">Pass： 12；Batch：110；Loss：0.01096；Accuracy：1.00000</span><br><span class="line">Pass： 13；Batch：110；Loss：0.00288；Accuracy：1.00000</span><br><span class="line">Pass： 14；Batch：110；Loss：0.00631；Accuracy：1.00000</span><br><span class="line">Pass： 15；Batch：110；Loss：0.00285；Accuracy：1.00000</span><br><span class="line">Pass： 16；Batch：110；Loss：0.00256；Accuracy：1.00000</span><br><span class="line">Pass： 17；Batch：110；Loss：0.00322；Accuracy：1.00000</span><br><span class="line">Pass： 18；Batch：110；Loss：0.00195；Accuracy：1.00000</span><br><span class="line">Pass： 19；Batch：110；Loss：0.00297；Accuracy：1.00000</span><br><span class="line">Pass： 20；Batch：110；Loss：0.00217；Accuracy：1.00000</span><br><span class="line">Pass： 21；Batch：110；Loss：0.00373；Accuracy：1.00000</span><br><span class="line">Pass： 22；Batch：110；Loss：0.00482；Accuracy：1.00000</span><br><span class="line">Pass： 23；Batch：110；Loss：0.00120；Accuracy：1.00000</span><br><span class="line">Pass： 24；Batch：110；Loss：0.00188；Accuracy：1.00000</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210211225405102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RYS19LZXZpbg==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20210211225405123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RYS19LZXZpbg==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="4-模型评估-3">4. 模型评估</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():       <span class="comment"># 使用动态图进行模型测试</span></span><br><span class="line">    test_costs, test_accs = [], []</span><br><span class="line">    model = MyLeNet()    <span class="comment"># 模型实例化</span></span><br><span class="line">    model_dict, _ = fluid.load_dygraph(<span class="string">&quot;MyLeNet&quot;</span>)  <span class="comment"># 加载模型参数</span></span><br><span class="line">    model.load_dict(model_dict)         <span class="comment"># 将模型参数载入到新模型中</span></span><br><span class="line">    model.<span class="built_in">eval</span>()         <span class="comment"># 开启评估模式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_reader()):</span><br><span class="line">        <span class="comment"># 将数据集中的图像、标签数据转化为特定numpy数组格式的数据：</span></span><br><span class="line">        image = np.array([x[<span class="number">0</span>].reshape(<span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>) <span class="keyword">for</span> x <span class="keyword">in</span> data], np.float32)</span><br><span class="line">        label = np.array([x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> data]).astype(<span class="string">&quot;int64&quot;</span>)[:, np.newaxis]</span><br><span class="line">        <span class="comment"># 将数据转化为fluid.dygraph能够接受的Variable类型的对象：</span></span><br><span class="line">        image = fluid.dygraph.to_variable(image)</span><br><span class="line">        label = fluid.dygraph.to_variable(label)</span><br><span class="line"></span><br><span class="line">        predict = model(image)   <span class="comment"># 模型测试</span></span><br><span class="line">        test_loss = fluid.layers.cross_entropy(predict, label)  <span class="comment"># 计算交叉熵</span></span><br><span class="line">        avg_loss = fluid.layers.mean(test_loss)                 <span class="comment"># 计算平均损失值</span></span><br><span class="line">        test_costs.append(avg_loss.numpy()[<span class="number">0</span>])</span><br><span class="line">        test_acc = fluid.layers.accuracy(predict, label)        <span class="comment"># 计算准确率</span></span><br><span class="line">        test_accs.append(test_acc.numpy()[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    test_loss = np.mean(test_costs)     <span class="comment"># 计算平均损失值</span></span><br><span class="line">    test_acc = np.mean(test_accs)       <span class="comment"># 计算平均准确率</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Eval \t Avg_Loss：%.5f；Accuracy：%.5f&quot;</span> % (test_loss, test_acc))</span><br></pre></td></tr></table></figure><p>模型评估结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eval  Avg_Loss：0.12136；Accuracy：0.98006</span><br></pre></td></tr></table></figure><h2 id="5-模型预测-3">5. 模型预测</h2><ul><li><strong>预测图片预处理</strong><br>由于车牌图片是由多个字符构成的RGB模式的图片，因此在进行预测之前需要将车牌图片转化为灰度图并按字符划分子图像，以便于模型逐字符进行预测。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_image</span>(<span class="params">path</span>):          <span class="comment"># 图像整体预处理</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(path).convert(<span class="string">&quot;L&quot;</span>)    <span class="comment"># 将图像打开并转为灰度图</span></span><br><span class="line">    img = img.resize((<span class="number">32</span>, <span class="number">32</span>), Image.ANTIALIAS)</span><br><span class="line">    img = np.array(img).reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)\</span><br><span class="line">        .astype(<span class="string">&#x27;float32&#x27;</span>)          <span class="comment"># 把图像变成numpy数组以匹配数据馈送格式</span></span><br><span class="line">    img = img / <span class="number">255.0</span> * <span class="number">2.0</span> - <span class="number">1.0</span>   <span class="comment"># 将数据归一化到[-1, 1]之间</span></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide_picture</span>(<span class="params">path</span>):      <span class="comment"># 分割出车牌图像中的每一个字符并保存</span></span><br><span class="line">    <span class="comment"># (1) 图片灰度化处理：</span></span><br><span class="line">    license = cv2.imread(path)</span><br><span class="line">    gray_img = cv2.cvtColor(license, cv2.COLOR_RGB2GRAY)  <span class="comment"># 将车牌转化为灰度图</span></span><br><span class="line">    retval, bin_img = cv2.threshold(                      <span class="comment"># 进行图像二值化操作</span></span><br><span class="line">        gray_img, <span class="number">100</span>, <span class="number">255</span>, cv2.THRESH_BINARY  <span class="comment"># 源图片、起始阈值、最大阈值、阈值类型</span></span><br><span class="line">    )   <span class="comment"># 函数返回值：retval是阈值；bin_img是根据阈值处理后的图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># (2) 按列统计像素分布：</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(bin_img.shape[<span class="number">1</span>]):</span><br><span class="line">        result.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(bin_img.shape[<span class="number">0</span>]):</span><br><span class="line">            result[col] += bin_img[row][col] / <span class="number">255.0</span>    <span class="comment"># 统计归一化后的像素分布</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># (3) 记录车牌中的字符的位置：</span></span><br><span class="line">    place_dict, num, i = &#123;&#125;, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(result):</span><br><span class="line">        <span class="keyword">if</span> result[i] == <span class="number">0</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            index = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> result[index] != <span class="number">0</span>:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            place_dict[num] = [i, index-<span class="number">1</span>]</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            i = index</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (4) 将每个字符填充并存储：</span></span><br><span class="line">    characters = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span>:   <span class="comment"># 跳过蓝牌中的“•”号</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        padding = (<span class="number">170</span> - (place_dict[i][<span class="number">1</span>] - place_dict[i][<span class="number">0</span>])) / <span class="number">2</span></span><br><span class="line">        ndarray = np.pad(     <span class="comment"># 将单个字符图像填充为170*170</span></span><br><span class="line">            bin_img[:, place_dict[i][<span class="number">0</span>]: place_dict[i][<span class="number">1</span>]],</span><br><span class="line">            ((<span class="number">0</span>, <span class="number">0</span>), (<span class="built_in">int</span>(padding), <span class="built_in">int</span>(padding))),</span><br><span class="line">            <span class="string">&quot;constant&quot;</span>,</span><br><span class="line">            constant_values=(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">        ndarray = cv2.resize(ndarray, (<span class="number">20</span>, <span class="number">20</span>))</span><br><span class="line">        cv2.imwrite(<span class="string">&quot;./data/%d.png&quot;</span> % i, ndarray)   <span class="comment"># 保存划分后的单字符图片</span></span><br><span class="line">        characters.append(ndarray)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">match_labels</span>(<span class="params">label_dict</span>):  <span class="comment"># 返回将标签进行转换的字典</span></span><br><span class="line">    temp = &#123;<span class="string">&#x27;A&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>: <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>: <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>: <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>: <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>: <span class="string">&#x27;G&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;H&#x27;</span>: <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>: <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>: <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>: <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>: <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>: <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>: <span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;O&#x27;</span>: <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>: <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>: <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>: <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>: <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;T&#x27;</span>: <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;U&#x27;</span>: <span class="string">&#x27;U&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;V&#x27;</span>: <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>: <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>: <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>: <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>: <span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>: <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>: <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>: <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>: <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>: <span class="string">&#x27;8&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;9&#x27;</span>: <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;yun&#x27;</span>: <span class="string">&#x27;云&#x27;</span>, <span class="string">&#x27;cuan&#x27;</span>: <span class="string">&#x27;川&#x27;</span>, <span class="string">&#x27;hei&#x27;</span>: <span class="string">&#x27;黑&#x27;</span>, <span class="string">&#x27;zhe&#x27;</span>: <span class="string">&#x27;浙&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;ning&#x27;</span>: <span class="string">&#x27;宁&#x27;</span>, <span class="string">&#x27;jin&#x27;</span>: <span class="string">&#x27;津&#x27;</span>, <span class="string">&#x27;gan&#x27;</span>: <span class="string">&#x27;赣&#x27;</span>, <span class="string">&#x27;hu&#x27;</span>: <span class="string">&#x27;沪&#x27;</span>, <span class="string">&#x27;liao&#x27;</span>: <span class="string">&#x27;辽&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;jl&#x27;</span>: <span class="string">&#x27;吉&#x27;</span>, <span class="string">&#x27;qing&#x27;</span>: <span class="string">&#x27;青&#x27;</span>, <span class="string">&#x27;zang&#x27;</span>: <span class="string">&#x27;藏&#x27;</span>, <span class="string">&#x27;e1&#x27;</span>: <span class="string">&#x27;鄂&#x27;</span>, <span class="string">&#x27;meng&#x27;</span>: <span class="string">&#x27;蒙&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;gan1&#x27;</span>: <span class="string">&#x27;甘&#x27;</span>, <span class="string">&#x27;qiong&#x27;</span>: <span class="string">&#x27;琼&#x27;</span>, <span class="string">&#x27;shan&#x27;</span>: <span class="string">&#x27;陕&#x27;</span>, <span class="string">&#x27;min&#x27;</span>: <span class="string">&#x27;闽&#x27;</span>, <span class="string">&#x27;su&#x27;</span>: <span class="string">&#x27;苏&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;xin&#x27;</span>: <span class="string">&#x27;新&#x27;</span>, <span class="string">&#x27;wan&#x27;</span>: <span class="string">&#x27;皖&#x27;</span>, <span class="string">&#x27;jing&#x27;</span>: <span class="string">&#x27;京&#x27;</span>, <span class="string">&#x27;xiang&#x27;</span>: <span class="string">&#x27;湘&#x27;</span>, <span class="string">&#x27;gui&#x27;</span>: <span class="string">&#x27;贵&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;yu1&#x27;</span>: <span class="string">&#x27;渝&#x27;</span>, <span class="string">&#x27;yu&#x27;</span>: <span class="string">&#x27;豫&#x27;</span>, <span class="string">&#x27;ji&#x27;</span>: <span class="string">&#x27;冀&#x27;</span>, <span class="string">&#x27;yue&#x27;</span>: <span class="string">&#x27;粤&#x27;</span>, <span class="string">&#x27;gui1&#x27;</span>: <span class="string">&#x27;桂&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sx&#x27;</span>: <span class="string">&#x27;晋&#x27;</span>, <span class="string">&#x27;lu&#x27;</span>: <span class="string">&#x27;鲁&#x27;</span>&#125;      <span class="comment"># 本次转换的目的是转换字母和汉字</span></span><br><span class="line">    name_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> label_dict.items():</span><br><span class="line">        name_dict[key] = temp[val]</span><br><span class="line">    <span class="keyword">return</span> name_dict</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():</span><br><span class="line">    model = MyLeNet()     <span class="comment"># 实例化模型</span></span><br><span class="line">    model_dict, _ = fluid.load_dygraph(<span class="string">&quot;MyLeNet&quot;</span>)  <span class="comment"># 加载模型参数</span></span><br><span class="line">    model.load_dict(model_dict)         <span class="comment"># 将模型参数载入到新模型中</span></span><br><span class="line">    model.<span class="built_in">eval</span>()          <span class="comment"># 开启评估模式</span></span><br><span class="line"></span><br><span class="line">    infer_label = <span class="string">&quot;&quot;</span>      <span class="comment"># 存储预测结果</span></span><br><span class="line">    infer_path = <span class="string">&quot;./work/infer_license.png&quot;</span>  <span class="comment"># 预测图片的路径</span></span><br><span class="line">    divide_picture(infer_path)               <span class="comment"># 按车牌字符划分图片</span></span><br><span class="line">    name_dict = match_labels(label_dict)     <span class="comment"># 获取转换标签的字典</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span>:     <span class="comment"># 跳过蓝牌中的“•”号</span></span><br><span class="line">            infer_label += <span class="string">&quot;•&quot;</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        char_img = load_image(<span class="string">&quot;./data/%d.png&quot;</span> % i)</span><br><span class="line">        <span class="comment"># 将数据转化为fluid.dygraph能够接受的Variable类型的对象：</span></span><br><span class="line">        char_img = fluid.dygraph.to_variable(char_img)</span><br><span class="line">        result = model(char_img)            <span class="comment"># 模型预测，返回一个概率数组</span></span><br><span class="line">        lab = np.argmax(result.numpy())     <span class="comment"># 返回数组result中的最大值的索引值</span></span><br><span class="line">        infer_label += name_dict[<span class="built_in">str</span>(lab)]  <span class="comment"># 将字符的预测结果加入到总结果中</span></span><br><span class="line"></span><br><span class="line">    display(Image.<span class="built_in">open</span>(infer_path))             <span class="comment"># 展示预测车牌</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n该车牌的预测结果为:&quot;</span>, infer_label)  <span class="comment"># 展示预测结果</span></span><br></pre></td></tr></table></figure><p>模型预测结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该车牌的预测结果为: 苏A•UP678</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210211225000923.png#pic_center" alt=""></p><hr/><blockquote><h1>写在最后</h1><ul><li>如果您发现项目存在问题，或者如果您有更好的建议，欢迎在下方评论区中留言讨论~</li><li>这是本项目的链接：<a href="https://aistudio.baidu.com/aistudio/projectdetail/764714?shared=1">实验项目 - AI Studio</a>，点击<code>fork</code>可直接在AI Studio运行~</li><li>这是我的个人主页：<a href="https://aistudio.baidu.com/aistudio/personalcenter/thirdview/118633">个人主页 - AI Studio</a>，来AI Studio互粉吧，等你哦~</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DNN】手写数字识别</title>
      <link href="/2020/08/27/%E3%80%90DNN%E3%80%91%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
      <url>/2020/08/27/%E3%80%90DNN%E3%80%91%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1>问题导入</h1><p>图像分类是根据图像的语义信息将不同类别图像区分开来，是计算机视觉中重要的基本问题。现有10类若干张手写数字图片，请使用多层感知器训练DNN模型预测手写数字图片：</p><p><img src="https://img-blog.csdnimg.cn/20210208100153448.png#pic_center" alt=""></p><hr/><h1>一、数据集简介</h1><p>本实验使用的是PaddlePaddle提供的mnist数据集（paddle.dataset.mnist），它包含60000个训练集和10000测试数据集，分为图片和标签，图片是 28 * 28 的像素矩阵，标签为0~9共10个数字：<br><img src="https://img-blog.csdnimg.cn/202102081005013.png#pic_center" alt=""></p><hr/><h1>二、实验步骤</h1><h2 id="1-导入模块">1. 导入模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">from</span> paddle <span class="keyword">import</span> fluid</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h2 id="2-数据准备">2. 数据准备</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BUF_SIZE, BATCH_SIZE = <span class="number">512</span>, <span class="number">128</span></span><br><span class="line"></span><br><span class="line">train_reader = paddle.batch(   <span class="comment"># 用于训练的数据提供器</span></span><br><span class="line">    paddle.reader.shuffle(</span><br><span class="line">        paddle.dataset.mnist.train(), buf_size=BUF_SIZE</span><br><span class="line">    ),  <span class="comment"># 每次缓存BUF_SIZE个训练数据项，并打乱</span></span><br><span class="line">    batch_size=BATCH_SIZE</span><br><span class="line">)   <span class="comment"># 按批次读取乱序后的训练数据，批次大小为BATCH_SIZE</span></span><br><span class="line"></span><br><span class="line">test_reader = paddle.batch(   <span class="comment"># 用于测试的数据提供器</span></span><br><span class="line">    paddle.reader.shuffle(</span><br><span class="line">        paddle.dataset.mnist.test(), buf_size=BUF_SIZE</span><br><span class="line">    ),  <span class="comment"># 每次缓存BUF_SIZE个测试数据项，并打乱</span></span><br><span class="line">    batch_size=BATCH_SIZE</span><br><span class="line">)   <span class="comment"># 按批次读取乱序后的测试数据，批次大小为BATCH_SIZE</span></span><br></pre></td></tr></table></figure><h2 id="3-模型配置">3. 模型配置</h2><ul><li><strong>定义多层感知器</strong><br>本实验定义的是一个多层感知器，它一共有三层（不含输入层）：即两个大小为100的隐藏层和一个大小为10的输出层。<br><img src="https://img-blog.csdnimg.cn/img_convert/8d8e46829d0b0aebc64e9800c9594cc4.png#pic_center" alt=""></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multilayer_perceptron</span>(<span class="params">entry</span>):   <span class="comment"># 定义多层感知器</span></span><br><span class="line">    <span class="comment"># 第一个全连接隐藏层，大小为100，激活函数为RelU：</span></span><br><span class="line">    hidden1 = fluid.layers.fc(<span class="built_in">input</span>=entry, size=<span class="number">100</span>, act=<span class="string">&quot;relu&quot;</span>)</span><br><span class="line">    <span class="comment"># 第二个全连接隐藏层，大小为100，激活函数为RelU：</span></span><br><span class="line">    hidden2 = fluid.layers.fc(<span class="built_in">input</span>=hidden1, size=<span class="number">100</span>, act=<span class="string">&quot;relu&quot;</span>)</span><br><span class="line">    <span class="comment"># 以Softmax为激活函数的全连接输出层，输出层的大小为数字的个数10：</span></span><br><span class="line">    prediction = fluid.layers.fc(<span class="built_in">input</span>=hidden2, size=<span class="number">10</span>, act=<span class="string">&quot;softmax&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> prediction</span><br></pre></td></tr></table></figure><ul><li><strong>定义数据层和分类器</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义输入的图像张量，图像为“单通道、28*28”的灰度图：</span></span><br><span class="line">image = fluid.layers.data(name=<span class="string">&quot;image&quot;</span>, shape=[<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>], dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"><span class="comment"># 定义标签张量，对应输入图片的类别标签：</span></span><br><span class="line">label = fluid.layers.data(name=<span class="string">&quot;label&quot;</span>, shape=[<span class="number">1</span>], dtype=<span class="string">&quot;int64&quot;</span>)</span><br><span class="line"><span class="comment"># 获取DNN分类器</span></span><br><span class="line">predict = multilayer_perceptron(image)</span><br></pre></td></tr></table></figure><blockquote><p>注：上面的多层感知器输入的是图像数据，而输入图像是 28×28 的灰度图，因为灰度图只有一个通道，其像素矩阵排列为1×28×28的，故输入的形状是[1, 28, 28]。</p></blockquote><ul><li><strong>定义损失函数和准确率</strong><br>本次实验使用交叉熵损失函数，该函数是分类问题中经常使用的一种损失函数。交叉熵 (Cross Entropy) 能够衡量同一个随机变量中的两个不同概率分布的差异程度，在深度学习中就表示为真实概率分布与预测概率分布之间的差异。交叉熵的值越小，模型预测效果就越好。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cost = fluid.layers.cross_entropy(<span class="built_in">input</span>=predict, label=label)  <span class="comment"># 交叉熵损失函数</span></span><br><span class="line">avg_cost = fluid.layers.mean(cost)                           <span class="comment"># 对损失值求平均值</span></span><br><span class="line">accuracy = fluid.layers.accuracy(<span class="built_in">input</span>=predict, label=label)   <span class="comment"># 计算分类准确率</span></span><br></pre></td></tr></table></figure><ul><li><strong>定义优化函数</strong><br>Adam 优化算法是一种对随机梯度下降 (SDG) 算法的扩展。SDG 算法保持单一的学习率更新所有的权重，学习率在训练过程中并不会改变；而 Adam 算法通过计算梯度的一阶矩估计和二阶矩估计而为不同的参数设计独立的自适应性学习率。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用Adam优化算法进行优化，learning_rate代表学习率：</span></span><br><span class="line">optimizer = fluid.optimizer.AdamOptimizer(learning_rate=<span class="number">0.001</span>)</span><br><span class="line">opts = optimizer.minimize(avg_cost)</span><br></pre></td></tr></table></figure><h2 id="4-训练与评估">4. 训练与评估</h2><ul><li><strong>创建训练用Executor</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">use_cuda = <span class="literal">False</span>    <span class="comment"># True代表使用GPU，False代表使用CPU</span></span><br><span class="line">place = fluid.CUDAPlace(<span class="number">0</span>) <span class="keyword">if</span> use_cuda <span class="keyword">else</span> fluid.CPUPlace()  <span class="comment"># 指定运行环境</span></span><br><span class="line">exe = fluid.Executor(place)</span><br><span class="line">exe.run(fluid.default_startup_program())   <span class="comment"># 运行初始化操作函数</span></span><br></pre></td></tr></table></figure><ul><li><strong>定义数据映射器</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">feeder = fluid.DataFeeder(place=place, feed_list=[image, label])</span><br></pre></td></tr></table></figure><ul><li><strong>开始训练</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">EPOCH_NUM, train_iter = <span class="number">2</span>, <span class="number">0</span></span><br><span class="line">train_iters, train_costs, train_accs = [], [], []</span><br><span class="line">test_program = fluid.default_main_program().clone(for_test=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 注：这里的clone并不是单纯的复制，训练函数和测试函数的机制略有不同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pass_id <span class="keyword">in</span> <span class="built_in">range</span>(EPOCH_NUM):   <span class="comment"># 训练EPOCH_NUM轮</span></span><br><span class="line">    <span class="comment"># (1) 进行训练：</span></span><br><span class="line">    <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_reader()):</span><br><span class="line">        train_cost, train_acc = exe.run(</span><br><span class="line">            program=fluid.default_main_program(),  <span class="comment"># 运行主程序</span></span><br><span class="line">            feed=feeder.feed(data),                <span class="comment"># 给模型喂入数据</span></span><br><span class="line">            fetch_list=[avg_cost, accuracy]        <span class="comment"># 返回误差、准确率</span></span><br><span class="line">        )</span><br><span class="line">        train_iter += BATCH_SIZE</span><br><span class="line">        train_iters.append(train_iter)       <span class="comment"># 迭代次数</span></span><br><span class="line">        train_costs.append(train_cost[<span class="number">0</span>])    <span class="comment"># 训练误差</span></span><br><span class="line">        train_accs.append(train_acc[<span class="number">0</span>])      <span class="comment"># 训练准确率</span></span><br><span class="line">        <span class="keyword">if</span> batch_id % <span class="number">100</span> == <span class="number">0</span>:    <span class="comment"># 每100批次输出一次训练结果</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Pass：%d，Batch：%3d，Cost：%0.5f，Accuracy：%0.5f&quot;</span> %</span><br><span class="line">                    (pass_id, batch_id, train_cost[<span class="number">0</span>], train_acc[<span class="number">0</span>]))</span><br><span class="line">    <span class="comment"># (2) 进行评估：</span></span><br><span class="line">    test_costs, test_accs = [], []</span><br><span class="line">    <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_reader()):</span><br><span class="line">        test_cost, test_acc = exe.run(</span><br><span class="line">            program=test_program,            <span class="comment"># 运行测试程序</span></span><br><span class="line">            feed=feeder.feed(data),          <span class="comment"># 给模型喂入数据</span></span><br><span class="line">            fetch_list=[avg_cost, accuracy]  <span class="comment"># 返回误差、准确率</span></span><br><span class="line">        )</span><br><span class="line">        test_costs.append(test_cost[<span class="number">0</span>])      <span class="comment"># 测试误差</span></span><br><span class="line">        test_accs.append(test_acc[<span class="number">0</span>])        <span class="comment"># 测试准确率</span></span><br><span class="line">    test_cost = <span class="built_in">sum</span>(test_costs) / <span class="built_in">len</span>(test_costs)   <span class="comment"># 每轮测试的平均误差</span></span><br><span class="line">    test_acc = <span class="built_in">sum</span>(test_accs) / <span class="built_in">len</span>(test_accs)      <span class="comment"># 每轮测试的平均准确率</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test：%d，Cost：%0.5f，Accuracy：%0.5f&quot;</span> %</span><br><span class="line">            (pass_id, test_cost, test_acc))   <span class="comment"># 输出每轮测试结果</span></span><br></pre></td></tr></table></figure><p>模型训练和评估结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass：0，Batch：  0，Cost：2.82746，Accuracy：0.08594</span><br><span class="line">Pass：0，Batch：100，Cost：0.50254，Accuracy：0.81250</span><br><span class="line">Pass：0，Batch：200，Cost：0.33552，Accuracy：0.93750</span><br><span class="line">Pass：0，Batch：300，Cost：0.25554，Accuracy：0.90625</span><br><span class="line">Pass：0，Batch：400，Cost：0.27948，Accuracy：0.92188</span><br><span class="line">Test：0，Cost：0.20784，Accuracy：0.93849</span><br><span class="line">Pass：1，Batch：  0，Cost：0.30901，Accuracy：0.94531</span><br><span class="line">Pass：1，Batch：100，Cost：0.19300，Accuracy：0.92188</span><br><span class="line">Pass：1，Batch：200，Cost：0.22428，Accuracy：0.94531</span><br><span class="line">Pass：1，Batch：300，Cost：0.21740，Accuracy：0.93750</span><br><span class="line">Pass：1，Batch：400，Cost：0.10877，Accuracy：0.96875</span><br><span class="line">Test：1，Cost：0.15736，Accuracy：0.95105</span><br></pre></td></tr></table></figure><ul><li><strong>保存模型</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_save_dir = <span class="string">&quot;Handwrite.model&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(model_save_dir):</span><br><span class="line">    os.makedirs(model_save_dir)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n save models to %s&#x27;</span> % (model_save_dir))</span><br><span class="line"><span class="comment"># 保存训练参数到指定路径中，构建一个专门用预测的program：</span></span><br><span class="line">fluid.io.save_inference_model(model_save_dir,  <span class="comment"># 保存推理模型的路径</span></span><br><span class="line">                              [<span class="string">&#x27;image&#x27;</span>],       <span class="comment"># 推理(inference)需要喂入的数据</span></span><br><span class="line">                              [predict],       <span class="comment"># 保存推理(inference)结果的变量</span></span><br><span class="line">                              exe)             <span class="comment"># exe保存inference model</span></span><br></pre></td></tr></table></figure><ul><li><strong>可视化训练结果</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=[<span class="number">10</span>, <span class="number">5</span>])</span><br><span class="line">plt.title(<span class="string">&quot;Model Training&quot;</span>, fontsize=<span class="number">25</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;iter&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;cost / accuracy&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">plt.plot(train_iters, train_costs, color=<span class="string">&quot;r&quot;</span>, label=<span class="string">&quot;cost&quot;</span>)</span><br><span class="line">plt.plot(train_iters, train_accs, color=<span class="string">&quot;g&quot;</span>, label=<span class="string">&quot;accuracy&quot;</span>)</span><br><span class="line">plt.legend(fontsize=<span class="number">16</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>可视化折线图绘制如下：<br><img src="https://img-blog.csdnimg.cn/20210208105906659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RYS19LZXZpbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="5-模型预测">5. 模型预测</h2><ul><li><strong>准备预测数据</strong></li></ul><blockquote><p>这是预测数据集的下载链接：<a href="https://aistudio.baidu.com/aistudio/datasetdetail/51183">手写数字预测数据集 - AI Studio</a>，它包含从0到9的10张数字图片。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_image</span>(<span class="params">path</span>):        <span class="comment"># 图片预处理</span></span><br><span class="line">    <span class="comment"># (1) 打开并展示图像：</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(path)   <span class="comment"># 打开图像</span></span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    plt.show()               <span class="comment"># 显示图像</span></span><br><span class="line">    <span class="comment"># (2) 格式化图像：</span></span><br><span class="line">    img = img.convert(<span class="string">&quot;L&quot;</span>)                 <span class="comment"># 将图像转化为灰度图像，L代表灰度图像</span></span><br><span class="line">    img = img.resize((<span class="number">28</span>, <span class="number">28</span>), Image.ANTIALIAS)  <span class="comment"># 将图像缩放为28*28的高质量图像</span></span><br><span class="line">    img = np.array(img).reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)\</span><br><span class="line">        .astype(np.float32)          <span class="comment"># 把图像变成一个numpy数组以匹配数据馈送格式</span></span><br><span class="line">    img = img / <span class="number">255.0</span> * <span class="number">2.0</span> - <span class="number">1.0</span>    <span class="comment"># 将数据归一化到[-1, 1]之间</span></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">truth_lab = randint(<span class="number">0</span>, <span class="number">9</span>)               <span class="comment"># 预测图片的真实标签</span></span><br><span class="line">img_path = <span class="string">&quot;data/infer_%d.png&quot;</span>   <span class="comment"># 预测图片的路径（注意更改路径）</span></span><br><span class="line">img = load_image(img_path % truth_lab)<span class="comment"># 获取预测图片</span></span><br></pre></td></tr></table></figure><p>随机选取的预测图片如下：<br><img src="https://img-blog.csdnimg.cn/20210208110620596.png" alt=""></p><ul><li><strong>创建预测用Executor</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">infer_exe = fluid.Executor(place)    <span class="comment"># 预测用Executor</span></span><br><span class="line">infer_scope = fluid.core.Scope()     <span class="comment"># Scope指定作用域</span></span><br></pre></td></tr></table></figure><ul><li><strong>载入模型并开始预测</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> fluid.scope_guard(infer_scope):</span><br><span class="line">    [infer_program,        <span class="comment"># 推理的program</span></span><br><span class="line">    feed_target_names,     <span class="comment"># 需要在推理函数提供数据的变量名列表</span></span><br><span class="line">    fetch_targets          <span class="comment"># 推断结果参数列表</span></span><br><span class="line">    ] = fluid.io.load_inference_model(model_save_dir, infer_exe)  <span class="comment"># 载入模型</span></span><br><span class="line"></span><br><span class="line">    result = infer_exe.run(program=infer_program,              <span class="comment"># 运行推测程序</span></span><br><span class="line">                           feed=&#123;feed_target_names[<span class="number">0</span>]: img&#125;,   <span class="comment"># 喂入要预测的图像</span></span><br><span class="line">                           fetch_list=fetch_targets)           <span class="comment"># 得到推测结果</span></span><br><span class="line">    infer_lab = np.argmax(result)   <span class="comment"># 返回数组result中的最大值的索引值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;图片的真实标签为%d，模型预测结果为%d&quot;</span> % (truth_lab, infer_lab))</span><br></pre></td></tr></table></figure><p>模型最终的预测结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图片的真实标签为2，模型预测结果为2</span><br></pre></td></tr></table></figure><hr/><h1>实验总结</h1><ul><li><strong>深度学习实验的三部曲</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/38934b94a50f5ce001f2d35d08752dd5.png#pic_center" alt=""></li><li><strong>深度学习实验的一般步骤</strong><br><img src="https://img-blog.csdnimg.cn/20210208110405937.png#pic_center" alt=""></li></ul><hr/><blockquote><h1>写在最后</h1><ul><li>如果您发现项目存在问题，或者如果您有更好的建议，欢迎在下方评论区中留言讨论~</li><li>这是本项目的链接：<a href="https://aistudio.baidu.com/aistudio/projectdetail/760892?shared=1">实验项目 - AI Studio</a>，点击<code>fork</code>可直接在AI Studio运行~</li><li>这是我的个人主页：<a href="https://aistudio.baidu.com/aistudio/personalcenter/thirdview/118633">个人主页 - AI Studio</a>，来AI Studio互粉吧，等你哦~</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【KMeans】基于经纬度的城市聚类</title>
      <link href="/2020/08/23/%E3%80%90KMeans%E3%80%91%E5%9F%BA%E4%BA%8E%E7%BB%8F%E7%BA%AC%E5%BA%A6%E7%9A%84%E5%9F%8E%E5%B8%82%E8%81%9A%E7%B1%BB/"/>
      <url>/2020/08/23/%E3%80%90KMeans%E3%80%91%E5%9F%BA%E4%BA%8E%E7%BB%8F%E7%BA%AC%E5%BA%A6%E7%9A%84%E5%9F%8E%E5%B8%82%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1>一、项目准备</h1><h2 id="1-问题导入-2">1. 问题导入</h2><p>K-means聚类算法是一种非层次聚类算法，在最小误差的基础上将数据划分了特定的类，类间利用距离作为相似度指标，两个向量之间的距离越小，其相似度就越高。已知中国部分二级城市的经纬度，要求利用经纬度坐标进行K-Means聚类分析。</p><h2 id="2-数据集简介-2">2. 数据集简介</h2><p>本案例的数据集包含4列351行数据，每行数据包含一个城市，其中前两列为城市所在省和市，最后两列为城市的经纬度。</p><blockquote><p>这是数据集的下载链接：<a href="https://aistudio.baidu.com/aistudio/datasetdetail/49718">中国主要城市经纬度数据集 - AI Studio</a></p></blockquote><hr/><h1>二、K-Means算法</h1><ul><li><p><strong>K-Means算法的特点</strong><br>K-Means聚类算法是一种基于向量距离作为相似性的评价指标，即认为两个对象的距离越近，其相似度就越大。该算法认为类簇是由距离靠近的对象组成的，因此它把得到紧凑且独立的类簇作为聚类的最终目标。<br>综上所述，K-Means算法划分的k个聚类具有以下特点：各聚类内部的元素尽可能的紧凑，而各聚类之间的元素尽可能的分开。</p></li><li><p><strong>K-Means算法的流程</strong><br>k-means算法的基础是最小误差平方和准则，k-means算法具体流程如下：<br>（1）从n个样本对象任意选择k个对象作为初始聚类中心；<br>（2）根据在步骤 (1) 中设置的k个聚类中心，计算每个对象与这k个中心的距离；<br>（3）经过步骤 (2) 的计算，所有对象与这个k个中心的距离就计算出来了，接着把所有对象与离它最近的中心归在一个类簇中；<br>（4）重新计算每个类簇的中心对象的位置；<br>（5）重复步骤 (3) 和 (4)，直到类簇聚类方案中的对象归类几乎不发生变化为止。</p></li><li><p><strong>K-Means算法的注意事项</strong><br>需要事先给定“类簇的数量”或者“初始的类中心”。</p></li><li><p><strong>K-Means算法的缺陷</strong><br>（1）种子点的个数要事先确定，但是我们一般很难估计它的个数。<br>（2）K-Means算法需要初始种子点，并且随机种子会影响计算结果。<br>（3）需要不断地计算调整后的类簇中心，当数据量很大时，这个计算所需的时间就会很大。</p></li></ul><hr/><h1>三、实验步骤</h1><h2 id="0-导入模块-2">0.导入模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h2 id="1-读入数据">1.读入数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;China_cities.csv&#x27;</span>)  <span class="comment"># 此处注意换成自己的数据集路径</span></span><br><span class="line"><span class="built_in">print</span>(df.head())  <span class="comment"># 展示前5行数据</span></span><br></pre></td></tr></table></figure><p>前5行数据的输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     省级行政区      城市       北纬        东经</span><br><span class="line">0       北京        北京市   39.904690   116.40717</span><br><span class="line">1       天津        天津市   39.085100   117.19937</span><br><span class="line">2       上海        上海市   31.230370   121.47370</span><br><span class="line">3       重庆        重庆市   29.564710   106.55073</span><br><span class="line">4  香港特别行政区    九龙    22.327115   114.17495</span><br></pre></td></tr></table></figure><h2 id="2-数据预处理">2.数据预处理</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = df.drop(<span class="string">&#x27;省级行政区&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">x = x.drop(<span class="string">&quot;城市&quot;</span>, axis=<span class="number">1</span>)</span><br><span class="line">x_np = np.array(x)        <span class="comment"># 将x转化为numpy数组</span></span><br></pre></td></tr></table></figure><h2 id="4-模型构建与训练">4.模型构建与训练</h2><p>本项目使用“K-Means聚类算法”来对城市的经纬度特征进行聚类。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n_clusters = <span class="number">7</span>                  <span class="comment"># 类簇的数量</span></span><br><span class="line">estimator = KMeans(n_clusters)  <span class="comment"># 构建聚类器</span></span><br><span class="line">estimator.fit(x)</span><br><span class="line"><span class="built_in">print</span>(estimator.cluster_centers_)<span class="comment"># 输出类簇中心</span></span><br></pre></td></tr></table></figure><p>K-Means聚类的类簇中心：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[ 36.30742841 105.21526409]</span><br><span class="line"> [ 27.85671809 102.12971362]</span><br><span class="line"> [ 41.34384438  84.09634   ]</span><br><span class="line"> [ 44.01411423 124.90852352]</span><br><span class="line"> [ 24.3572954  111.87362376]</span><br><span class="line"> [ 29.06106948 118.51486687]</span><br><span class="line"> [ 36.22217001 115.34626425]]</span><br></pre></td></tr></table></figure><h2 id="5-数据可视化">5.数据可视化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">markers = [<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]      <span class="comment"># 标记样式列表</span></span><br><span class="line">colors = [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>]  <span class="comment"># 标记颜色列表</span></span><br><span class="line">labels = estimator.labels_      <span class="comment"># 获取聚类标签</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">9</span>, <span class="number">6</span>))</span><br><span class="line">plt.title(<span class="string">&quot;Major Cities in China&quot;</span>, fontsize=<span class="number">25</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;East Longitude&#x27;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;North Latitude&#x27;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_clusters):    <span class="comment"># 遍历所有城市，绘制散点图</span></span><br><span class="line">    members = labels == i      <span class="comment"># members是一个布尔型数组</span></span><br><span class="line">    plt.scatter(</span><br><span class="line">        x_np[members, <span class="number">1</span>],      <span class="comment"># 城市经度数组</span></span><br><span class="line">        x_np[members, <span class="number">0</span>],      <span class="comment"># 城市纬度数组</span></span><br><span class="line">        marker = markers[i],   <span class="comment"># 标记样式</span></span><br><span class="line">        c = colors[i]          <span class="comment"># 标记颜色</span></span><br><span class="line">    )   <span class="comment"># 绘制散点图</span></span><br><span class="line"></span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>基于经纬度的城市聚类结果：<br><img src="https://img-blog.csdnimg.cn/20210206115113756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RYS19LZXZpbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><hr/><blockquote><h1>写在最后</h1><ul><li>如果您发现项目存在问题，或者如果您有更好的建议，欢迎在下方评论区中留言讨论~</li><li>这是本项目的链接：<a href="https://aistudio.baidu.com/aistudio/projectdetail/729321?shared=1">实验项目 - AI Studio</a>，点击<code>fork</code>可直接在AI Studio运行~</li><li>这是我的个人主页：<a href="https://aistudio.baidu.com/aistudio/personalcenter/thirdview/118633">个人主页 - AI Studio</a>，来AI Studio互粉吧，等你哦~</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 聚类问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【决策树】个人信贷风险预测</title>
      <link href="/2020/08/15/%E3%80%90%E5%86%B3%E7%AD%96%E6%A0%91%E3%80%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E8%B4%B7%E9%A3%8E%E9%99%A9%E9%A2%84%E6%B5%8B/"/>
      <url>/2020/08/15/%E3%80%90%E5%86%B3%E7%AD%96%E6%A0%91%E3%80%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E8%B4%B7%E9%A3%8E%E9%99%A9%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1>一、项目准备</h1><h2 id="1-问题导入-3">1. 问题导入</h2><p>随着技术的不断革新以及个人消费意识的改变，从互联网上借贷来满足生活需求或者实现个人增值，越来越受到大众的接受。请利用以往的信贷数据利用决策树构建一个风险控制模型，使其在后续的借贷业务中，能够提前识别出信贷风险，供投资者选择是否投资此项贷款。</p><h2 id="2-数据集简介-3">2. 数据集简介</h2><p>数据集中的数据是美国最大的P2P网贷交易平台Lending Club的历史数据，一共由9578行、14列数据构成：</p><blockquote><ol><li><strong>credit.policy</strong><br>客户是否满足Lending Club的授信标准（1为是，0为否）</li><li><strong>purpose</strong><br>表示贷款的目的（例：信用卡还款，债务处理，教育，购买大件，中小企业经营等等）</li><li><strong>int.rate</strong><br>贷款利率（较高的贷款利率意味着较高的风险）</li><li><strong>installment</strong><br>每月分期还款额</li><li><strong>log.annual.inc</strong><br>借贷者的年收入的自然对数</li><li><strong>dti</strong><br>借贷者的债务收入比（贷款收入比例，Delt-to-income）</li><li><strong>fico</strong><br>美国个人评分系统的评分。FICO得出的分数在300-850分之间，分数越高说明客户的信用风险越小，但分数本身不能说明一个客户是好是坏，贷款方通常会将分数作为参考，来进行贷款决策。每个贷款方都有自己的贷款策略和标准，并且每种产品都会有自己的风险水平，从而决定了可以接受的信用分数水平。</li><li><strong>days.with.cr.line</strong><br>借贷者有信用额度的天数</li><li><strong>revol.bal</strong><br>借贷者的账户余额（尚未结清的金额）</li><li><strong>revol.util</strong><br>借贷者的信用账户利用率（使用的金额/授信的金额)</li><li><strong>inq.last.6mths</strong><br>借贷者在过去6个月被借款者咨询的次数</li><li><strong>delinq.2yrs</strong><br>借贷者在过去2年逾期还款超过30天的次数</li><li><strong>pub.rec</strong><br>借贷者公共事业记录差评的次数</li><li><strong>not.fully.paid</strong><br>表示不完全支付，要预测这个因变量，可供投资者选择是否投资此项贷款（0贷款，1不贷款）</li></ol></blockquote><blockquote><p>这是数据集的下载链接：<a href="https://aistudio.baidu.com/aistudio/datasetdetail/49208">Lending Club借贷数据 - AI Studio</a></p></blockquote><hr/><h1>二、实验步骤</h1><h2 id="0-导入模块-8">0.导入模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, classification_report, confusion_matrix</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br></pre></td></tr></table></figure><h2 id="1-数据预处理">1. 数据预处理</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;loan_data.csv&#x27;</span>)</span><br><span class="line">x = df.drop(<span class="string">&quot;not.fully.paid&quot;</span>, axis=<span class="number">1</span>)  <span class="comment"># 提取特征值（除“not.fully.paid”外的所有字段的值）</span></span><br><span class="line">y = df[<span class="string">&#x27;not.fully.paid&#x27;</span>]               <span class="comment"># 提取目标值（字段“not.fully.paid”对应的字段值）</span></span><br></pre></td></tr></table></figure><ul><li><strong>数据的描述性统计分析</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.describe().T)</span><br><span class="line"><span class="comment"># 表头：特征数据个数，平均值，标准差，最小值，1/4中位数，1/2中位数，3/4中位数，最大值</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                    count          mean           std         min  \</span><br><span class="line">credit.policy      9578.0      0.804970      0.396245    0.000000   </span><br><span class="line">int.rate           9578.0      0.122640      0.026847    0.060000   </span><br><span class="line">installment        9578.0    319.089413    207.071301   15.670000   </span><br><span class="line">log.annual.inc     9578.0     10.932117      0.614813    7.547502   </span><br><span class="line">dti                9578.0     12.606679      6.883970    0.000000   </span><br><span class="line">fico               9578.0    710.846314     37.970537  612.000000   </span><br><span class="line">days.with.cr.line  9578.0   4560.767197   2496.930377  178.958333   </span><br><span class="line">revol.bal          9578.0  16913.963876  33756.189557    0.000000   </span><br><span class="line">revol.util         9578.0     46.799236     29.014417    0.000000   </span><br><span class="line">inq.last.6mths     9578.0      1.577469      2.200245    0.000000   </span><br><span class="line">delinq.2yrs        9578.0      0.163708      0.546215    0.000000   </span><br><span class="line">pub.rec            9578.0      0.062122      0.262126    0.000000   </span><br><span class="line">not.fully.paid     9578.0      0.160054      0.366676    0.000000   </span><br><span class="line"></span><br><span class="line">                           25%          50%           75%           max  </span><br><span class="line">credit.policy         1.000000     1.000000      1.000000  1.000000e+00  </span><br><span class="line">int.rate              0.103900     0.122100      0.140700  2.164000e-01  </span><br><span class="line">installment         163.770000   268.950000    432.762500  9.401400e+02  </span><br><span class="line">log.annual.inc       10.558414    10.928884     11.291293  1.452835e+01  </span><br><span class="line">dti                   7.212500    12.665000     17.950000  2.996000e+01  </span><br><span class="line">fico                682.000000   707.000000    737.000000  8.270000e+02  </span><br><span class="line">days.with.cr.line  2820.000000  4139.958333   5730.000000  1.763996e+04  </span><br><span class="line">revol.bal          3187.000000  8596.000000  18249.500000  1.207359e+06  </span><br><span class="line">revol.util           22.600000    46.300000     70.900000  1.190000e+02  </span><br><span class="line">inq.last.6mths        0.000000     1.000000      2.000000  3.300000e+01  </span><br><span class="line">delinq.2yrs           0.000000     0.000000      0.000000  1.300000e+01  </span><br><span class="line">pub.rec               0.000000     0.000000      0.000000  5.000000e+00  </span><br><span class="line">not.fully.paid        0.000000     0.000000      0.000000  1.000000e+00  </span><br></pre></td></tr></table></figure><ul><li><strong>数据的相关性分析</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相关系数绝对值越大，表示相关性越大；相关系数为正，表示正相关；相关系数为负，表示负相关</span></span><br><span class="line"><span class="built_in">print</span>(df.corr())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   credit.policy  int.rate  installment  log.annual.inc  \</span><br><span class="line">credit.policy           1.000000 -0.294089     0.058770        0.034906   </span><br><span class="line">int.rate               -0.294089  1.000000     0.276140        0.056383   </span><br><span class="line">installment             0.058770  0.276140     1.000000        0.448102   </span><br><span class="line">log.annual.inc          0.034906  0.056383     0.448102        1.000000   </span><br><span class="line">dti                    -0.090901  0.220006     0.050202       -0.054065   </span><br><span class="line">fico                    0.348319 -0.714821     0.086039        0.114576   </span><br><span class="line">days.with.cr.line       0.099026 -0.124022     0.183297        0.336896   </span><br><span class="line">revol.bal              -0.187518  0.092527     0.233625        0.372140   </span><br><span class="line">revol.util             -0.104095  0.464837     0.081356        0.054881   </span><br><span class="line">inq.last.6mths         -0.535511  0.202780    -0.010419        0.029171   </span><br><span class="line">delinq.2yrs            -0.076318  0.156079    -0.004368        0.029203   </span><br><span class="line">pub.rec                -0.054243  0.098162    -0.032760        0.016506   </span><br><span class="line">not.fully.paid         -0.158119  0.159552     0.049955       -0.033439   </span><br><span class="line"></span><br><span class="line">                        dti      fico  days.with.cr.line  revol.bal  \</span><br><span class="line">credit.policy     -0.090901  0.348319           0.099026  -0.187518   </span><br><span class="line">int.rate           0.220006 -0.714821          -0.124022   0.092527   </span><br><span class="line">installment        0.050202  0.086039           0.183297   0.233625   </span><br><span class="line">log.annual.inc    -0.054065  0.114576           0.336896   0.372140   </span><br><span class="line">dti                1.000000 -0.241191           0.060101   0.188748   </span><br><span class="line">fico              -0.241191  1.000000           0.263880  -0.015553   </span><br><span class="line">days.with.cr.line  0.060101  0.263880           1.000000   0.229344   </span><br><span class="line">revol.bal          0.188748 -0.015553           0.229344   1.000000   </span><br><span class="line">revol.util         0.337109 -0.541289          -0.024239   0.203779   </span><br><span class="line">inq.last.6mths     0.029189 -0.185293          -0.041736   0.022394   </span><br><span class="line">delinq.2yrs       -0.021792 -0.216340           0.081374  -0.033243   </span><br><span class="line">pub.rec            0.006209 -0.147592           0.071826  -0.031010   </span><br><span class="line">not.fully.paid     0.037362 -0.149666          -0.029237   0.053699   </span><br><span class="line"></span><br><span class="line">                   revol.util  inq.last.6mths  delinq.2yrs   pub.rec  \</span><br><span class="line">credit.policy       -0.104095       -0.535511    -0.076318 -0.054243   </span><br><span class="line">int.rate             0.464837        0.202780     0.156079  0.098162   </span><br><span class="line">installment          0.081356       -0.010419    -0.004368 -0.032760   </span><br><span class="line">log.annual.inc       0.054881        0.029171     0.029203  0.016506   </span><br><span class="line">dti                  0.337109        0.029189    -0.021792  0.006209   </span><br><span class="line">fico                -0.541289       -0.185293    -0.216340 -0.147592   </span><br><span class="line">days.with.cr.line   -0.024239       -0.041736     0.081374  0.071826   </span><br><span class="line">revol.bal            0.203779        0.022394    -0.033243 -0.031010   </span><br><span class="line">revol.util           1.000000       -0.013880    -0.042740  0.066717   </span><br><span class="line">inq.last.6mths      -0.013880        1.000000     0.021245  0.072673   </span><br><span class="line">delinq.2yrs         -0.042740        0.021245     1.000000  0.009184   </span><br><span class="line">pub.rec              0.066717        0.072673     0.009184  1.000000   </span><br><span class="line">not.fully.paid       0.082088        0.149452     0.008881  0.048634   </span><br><span class="line"></span><br><span class="line">                   not.fully.paid  </span><br><span class="line">credit.policy           -0.158119  </span><br><span class="line">int.rate                 0.159552  </span><br><span class="line">installment              0.049955  </span><br><span class="line">log.annual.inc          -0.033439  </span><br><span class="line">dti                      0.037362  </span><br><span class="line">fico                    -0.149666  </span><br><span class="line">days.with.cr.line       -0.029237  </span><br><span class="line">revol.bal                0.053699  </span><br><span class="line">revol.util               0.082088  </span><br><span class="line">inq.last.6mths           0.149452  </span><br><span class="line">delinq.2yrs              0.008881  </span><br><span class="line">pub.rec                  0.048634  </span><br><span class="line">not.fully.paid           1.000000  </span><br></pre></td></tr></table></figure><h2 id="2-数据预处理-3">2. 数据预处理</h2><p>数据的预处理包括：数据的清洗、数据的采样、数据集划分、特征选择、特征降维、特征编码、规范化等过程。<br>下面重点强调一下“特征编码”和“数据集划分”这两个步骤：</p><ul><li><strong>特征编码</strong><br>在构建决策树时，每一个特征都应该是数值类型的，但是我们可以看出，purpose等列的取值都是字符型的（类别，categorical）。所以，必须经过一些转换，把这些类别都映射成为某个数值，才能进行后续步骤。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = defaultdict(LabelEncoder)</span><br><span class="line">x_trans = x.apply(<span class="keyword">lambda</span> x: dic[x.name].fit_transform(x))</span><br><span class="line"><span class="built_in">print</span>(x_trans.head())    <span class="comment"># 输出映射后的前5行数据</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   credit.policy  purpose  int.rate  installment  log.annual.inc   dti  fico  \</span><br><span class="line">0              1        2        76         4665            1462  1887    25   </span><br><span class="line">1              1        1        50         2116            1143  1380    19   </span><br><span class="line">2              1        2       115         3240             348  1115    14   </span><br><span class="line">3              1        2        38         1375            1462   767    20   </span><br><span class="line">4              1        1       132          759            1410  1446    11   </span><br><span class="line"></span><br><span class="line">   days.with.cr.line  revol.bal  revol.util  inq.last.6mths  delinq.2yrs  \</span><br><span class="line">0               1663       6606         530               0            0   </span><br><span class="line">1                632       6849         778               0            0   </span><br><span class="line">2               1363       1628         260               1            0   </span><br><span class="line">3                609       6852         743               1            0   </span><br><span class="line">4               1132       2115         403               0            1   </span><br><span class="line"></span><br><span class="line">   pub.rec  </span><br><span class="line">0        0  </span><br><span class="line">1        0  </span><br><span class="line">2        0  </span><br><span class="line">3        0  </span><br><span class="line">4        0  </span><br></pre></td></tr></table></figure><ul><li><strong>数据集划分</strong><br>训练集和测试集的划分 将整个数据集拆分成：训练集和测试集。不过，如果我们将其直接划分为训练集和数据集，那么就会造成数据分布不均的问题。好在sklearn为我们提供了划分训练集和数据集的方法。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[x_train, x_test,    <span class="comment"># 特征值x的训练集和测试集</span></span><br><span class="line"> y_train, y_test     <span class="comment"># 目标值y的训练集和测试集</span></span><br><span class="line">] = train_test_split(x_trans, y, random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="3-模型训练与预测-2">3. 模型训练与预测</h2><p>sklearn 中使用 sklearn.tree.DecisionTreeClassifier 类来实现决策树算法，其构造方法包含许多参数，比较常用的有以下几个：</p><p>（1）<strong>特征选择标准 criterion</strong></p><blockquote><ul><li>可选值：“gini”（基尼系数，默认）或 “entropy”（信息熵）</li><li>两种算法差异不大对准确率无影响，信息熵效率低一点，因为它有对数运算。一般说使用默认的基尼系数“gini”就可以了，即CART算法。</li></ul></blockquote><p>（2）<strong>随机状态数 random_state</strong></p><blockquote><ul><li>可选值：None（默认），int 或 RandomState</li><li>如果传入值为整数，则它指定了随机数生成器的种子；如果传入值为RandomState实例，则指定了随机数生成器；如果传入值为None，则使用默认的随机数生成器。</li></ul></blockquote><p>（3）<strong>特征划分标准 splitter</strong></p><blockquote><ul><li>可选值：“best”（最佳，默认）或 “random”（随机）</li><li>前者在特征的所有划分点中找出最优的划分点。后者是随机的在部分划分点中找局部最优的划分点。 默认的“best”适合样本量不大的时候，而如果样本数据量非常大，此时决策树构建推“random”。</li></ul></blockquote><p>（4）<strong>决策树最大深度 max_depth</strong></p><blockquote><ul><li>可选值：None（默认）或 int</li><li>一般来说，数据少或者特征少的时候可以不管这个值。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间。常用来防止模型出现过拟合。</li></ul></blockquote><p>（5）<strong>叶节点最少样本数 min_samples_leaf</strong></p><blockquote><ul><li>可选值：int（默认为1）或 float</li><li>如果值是 int型，则取传入值本身作为最小样本数；如果值是 float型，则取 ceil(min_samples_leaf * 样本数量) 的值作为最小样本数（ceil 函数的作用是向上取整）。min_samples_leaf 主要用于对决策树进行修剪，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。</li></ul></blockquote><p>（6）<strong>最大特征个数 max_features</strong></p><blockquote><ul><li>可选值：None（默认），int，float 或 string（“auto”, “sqrt”, “log2”）</li><li>max_features 一般配合 max_depth 使用，用作树的“精修”，它限制分枝时考虑的特征个数，超过限制个数的特征都会被舍弃。</li></ul></blockquote><p>（7）<strong>节点划分最小不纯度 min_impurity_decrease</strong></p><blockquote><ul><li>可选值：float（默认为0）</li><li>min_impurity_decrease 限制了决策树的增长，如果某节点的不纯度（基尼系数，信息增益，均方差，绝对差）小于这个阈值，则该节点不再生成子节点。</li></ul></blockquote><p>（8）<strong>内部节点再划分所需最小样本数 min_samples_split</strong></p><blockquote><ul><li>可选值：int（默认为2）或 float</li><li>如果值是 int型，则取传入值本身作为最小样本数；如果值是 float型，则取 ceil(min_samples_split * 样本数量) 的值作为最小样本数（ceil 函数的作用是向上取整）。</li></ul></blockquote><p>我们这里暂时先采用默认参数来构造决策树模型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt = DecisionTreeClassifier()    <span class="comment"># 以默认参数构建决策树模型</span></span><br><span class="line">dt.fit(x_train, y_train)         <span class="comment"># 训练模型</span></span><br><span class="line"></span><br><span class="line">dt_infer = dt.predict(x_test)    <span class="comment"># 预测结果</span></span><br><span class="line">dt_truth = <span class="built_in">list</span>(y_test)          <span class="comment"># 真实结果</span></span><br></pre></td></tr></table></figure><h2 id="4-模型评价-2">4. 模型评价</h2><p><img src="https://img-blog.csdnimg.cn/821d0843671446aca2be1f7228bd15b9.jpeg#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/19d5ba67364748c684f302b31c758b23.jpeg#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/a0342710efb840dfad92bf373b292976.jpeg#pic_center" alt=""></p><ul><li><strong>预测准确率</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Accuracy \t %.8f&quot;</span> % accuracy_score(dt_truth, dt_infer))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accuracy  0.73903967</span><br></pre></td></tr></table></figure><ul><li><strong>混淆矩阵</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(confusion_matrix(dt_truth, dt_infer))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1668  324]</span><br><span class="line"> [ 301  102]]</span><br></pre></td></tr></table></figure><ul><li><strong>分类报告</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(classification_report(dt_truth, dt_infer))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">              precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">           0       0.85      0.84      0.84      1992</span><br><span class="line">           1       0.24      0.25      0.25       403</span><br><span class="line"></span><br><span class="line">   micro avg       0.74      0.74      0.74      2395</span><br><span class="line">   macro avg       0.54      0.55      0.54      2395</span><br><span class="line">weighted avg       0.74      0.74      0.74      2395</span><br></pre></td></tr></table></figure><h2 id="5-模型调优">5. 模型调优</h2><p>模型的结果还可以通过优化来提升，在刚才的整个机器学习过程中，用的都是决策树的缺省值，下面通过设置DecisionTreeClassifier() 训练过程中的参数进行调优：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ndt = DecisionTreeClassifier(</span><br><span class="line">    max_depth=<span class="number">5</span>,            <span class="comment"># 决策树最大深度</span></span><br><span class="line">    min_samples_leaf=<span class="number">0.3</span>,   <span class="comment"># 叶节点最少样本数</span></span><br><span class="line">    max_features=<span class="number">1</span>          <span class="comment"># 最大特征个数</span></span><br><span class="line">)   <span class="comment"># 构建决策树模型</span></span><br><span class="line">ndt.fit(x_train, y_train)         <span class="comment"># 模型训练</span></span><br><span class="line">ndt_infer = ndt.predict(x_test)   <span class="comment"># 获取预测值</span></span><br><span class="line">ndt_truth = <span class="built_in">list</span>(y_test)          <span class="comment"># 获取真实值</span></span><br></pre></td></tr></table></figure><ul><li><strong>预测准确率</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Accruacy \t %.8f&quot;</span> % accuracy_score(ndt_truth, ndt_infer))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accruacy  0.83173278</span><br></pre></td></tr></table></figure><ul><li><strong>混淆矩阵</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(confusion_matrix(ndt_truth, ndt_infer))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1992    0]</span><br><span class="line"> [ 403    0]]</span><br></pre></td></tr></table></figure><hr/><blockquote><h1>写在最后</h1><ul><li>如果您发现项目存在问题，或者如果您有更好的建议，欢迎在下方评论区中留言讨论~</li><li>这是本项目的链接：<a href="https://aistudio.baidu.com/aistudio/projectdetail/716905?shared=1">实验项目 - AI Studio</a>，点击<code>fork</code>可直接在AI Studio运行~</li><li>这是我的个人主页：<a href="https://aistudio.baidu.com/aistudio/personalcenter/thirdview/118633">个人主页 - AI Studio</a>，来AI Studio互粉吧，等你哦~</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 分类问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SVM】鸢尾花分类</title>
      <link href="/2020/08/11/%E3%80%90SVM%E3%80%91%E9%B8%A2%E5%B0%BE%E8%8A%B1%E5%88%86%E7%B1%BB/"/>
      <url>/2020/08/11/%E3%80%90SVM%E3%80%91%E9%B8%A2%E5%B0%BE%E8%8A%B1%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1>一、项目准备</h1><h2 id="1-问题导入">1. 问题导入</h2><p>构建一个模型，根据鸢尾花的花萼大小和花瓣大小将其分为三种不同的品种：<br><img src="https://ai-studio-static-online.cdn.bcebos.com/3576ab90c3704a5e896cb36657ca570b286df1d93419407db16474e1c35162bc#pic_center" alt=""></p><h2 id="2-数据集简介">2. 数据集简介</h2><p>数据集共包含150行数据，每一行数据由四个特征值及一个目标值组成。<br>其中，四个特征值分别为：萼片长度、萼片宽度、花瓣长度、花瓣宽度；<br>目标值是鸢尾花的类别，即：Iris Setosa、Iris Versicolour、Iris Virginica。</p><blockquote><p>这是数据集的下载链接：<a href="https://aistudio.baidu.com/aistudio/datasetdetail/2301">鸢尾花数据集 - AI Studio</a></p></blockquote><hr/><h1>二、实验步骤</h1><h2 id="0-导入模块">0.导入模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h2 id="1-数据准备">1. 数据准备</h2><ul><li><strong>数据编码</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">iris_type</span>(<span class="params">s</span>):   <span class="comment"># 将鸢尾花的种类以整数形式表示，便于数据加载</span></span><br><span class="line">    it = &#123;</span><br><span class="line">        <span class="string">b&#x27;Iris-setosa&#x27;</span>: <span class="number">0</span>,      <span class="comment"># 山鸢尾</span></span><br><span class="line">        <span class="string">b&#x27;Iris-versicolor&#x27;</span>: <span class="number">1</span>,  <span class="comment"># 变色鸢尾</span></span><br><span class="line">        <span class="string">b&#x27;Iris-virginica&#x27;</span>: <span class="number">2</span>    <span class="comment"># 维吉尼亚鸢尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it[s]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_path = <span class="string">&#x27;iris.data&#x27;</span></span><br><span class="line">data = np.loadtxt(</span><br><span class="line">    data_path,                  <span class="comment"># 数据文件的路径</span></span><br><span class="line">    dtype=<span class="built_in">float</span>,                <span class="comment"># 数据类型</span></span><br><span class="line">    delimiter=<span class="string">&#x27;,&#x27;</span>,              <span class="comment"># 数据分隔符</span></span><br><span class="line">    converters=&#123;<span class="number">4</span>: iris_type&#125;   <span class="comment"># 将第5列数据用iris_type进行转换</span></span><br><span class="line">)   <span class="comment"># data为二维数组，且data.shape=(150, 5)</span></span><br></pre></td></tr></table></figure><ul><li><strong>数据分割</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x, y = np.split(</span><br><span class="line">    data,       <span class="comment"># 要切分的数组</span></span><br><span class="line">    (<span class="number">4</span>, ),      <span class="comment"># 沿轴切分的位置，前4列为x，第5列开始往后为y</span></span><br><span class="line">    axis=<span class="number">1</span>      <span class="comment"># 1代表纵向按列分割；默认0代表横向按行分割</span></span><br><span class="line">)</span><br><span class="line">x = x[:, <span class="number">0</span>:<span class="number">2</span>]   <span class="comment"># 为方便后期画图更直观，我们取x中的前两列作为特征</span></span><br></pre></td></tr></table></figure><ul><li><strong>数据集划分</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_train, x_test, y_train, y_test = train_test_split(</span><br><span class="line">    x,                <span class="comment"># 要划分的样本特征集</span></span><br><span class="line">    y,                <span class="comment"># 要划分的样本结果集</span></span><br><span class="line">    random_state=<span class="number">1</span>,   <span class="comment"># 随机数种子</span></span><br><span class="line">    test_size=<span class="number">0.3</span>     <span class="comment"># 测试样本占比</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="2-模型搭建">2. 模型搭建</h2><ul><li><strong>惩罚系数 C</strong></li></ul><blockquote><ul><li>C值大，对误分类的惩罚增大，这样趋向于训练集测试的准确率很高，但泛化能力弱</li><li>C值小，对误分类的惩罚减小，允许容错，泛化能力较强</li></ul></blockquote><ul><li><strong>内核 kernel</strong></li></ul><blockquote><ul><li>“linear”代表“线性核”，“rbf”代表“高斯核”。</li></ul></blockquote><ul><li><em>高斯核函数参数 gamma</em> *</li></ul><blockquote><ul><li>gamma是选择rbf函数作为kernel后，该函数的一个参数，它隐含地决定了数据映射到新的特征空间后的分布。</li><li>gamma越小，分类界面越连续；gamma越大，分类界面越“散”，分类效果越好，但可能过拟合。</li></ul></blockquote><ul><li><strong>划分方法 decision_function_shape</strong></li></ul><blockquote><ul><li>“ovr”代表“one v rest”，即一个类别与其他类别进行划分；</li><li>“ovo”代表“one v one”，即将类别两两之间进行划分，用二分类的方法模拟多分类的结果。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 高斯核的svm分类器：</span></span><br><span class="line"><span class="comment"># clf = svm.SVC(C=0.8, kernel=&#x27;rbf&#x27;, gamma=50, decision_function_shape=&#x27;ovr&#x27;)</span></span><br><span class="line"><span class="comment"># 线性核的svm分类器：</span></span><br><span class="line">clf = svm.SVC(C=<span class="number">0.5</span>, kernel=<span class="string">&#x27;linear&#x27;</span>, decision_function_shape=<span class="string">&#x27;ovr&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="3-模型训练">3. 模型训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf.fit(x_train,            <span class="comment"># 训练集特征向量</span></span><br><span class="line">        y_train.ravel())    <span class="comment"># 训练集目标值；ravel()函数可将矩阵转变成一维数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-模型评估">4. 模型评估</h2><ul><li><strong>评分与准确率</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_accuracy</span>(<span class="params">a, b, tip</span>):   <span class="comment"># 判断a和b是否相等，并计算准确率的均值</span></span><br><span class="line">    acc = a.ravel() == b.ravel()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s上的准确率 \t %.3f&quot;</span> % (tip, np.mean(acc)))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练集上的评分 \t %.3f&quot;</span> % clf.score(x_train, y_train))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试集上的评分 \t %.3f&quot;</span> % clf.score(x_test, y_test))</span><br><span class="line"></span><br><span class="line">show_accuracy(clf.predict(x_train), y_train, <span class="string">&quot;训练集&quot;</span>)</span><br><span class="line">show_accuracy(clf.predict(x_test), y_test, <span class="string">&quot;测试集&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">训练集上的评分  0.819</span><br><span class="line">测试集上的评分  0.778</span><br><span class="line">训练集上的准确率  0.819</span><br><span class="line">测试集上的准确率  0.778</span><br></pre></td></tr></table></figure><ul><li><strong>决策函数的值</strong><br>决策函数的值表示x到各分割平面的距离。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values = clf.decision_function(x_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Iris-setosa \t Iris-versicolor \t Iris-virginica&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> lt <span class="keyword">in</span> values:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%9.6f \t %9.6f \t\t %9.6f&quot;</span> % <span class="built_in">tuple</span>(lt))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iris-setosa  Iris-versicolor  Iris-virginica</span><br><span class="line">-0.500000   1.208873   2.291127</span><br><span class="line"> 2.063288  -0.076968   1.013680</span><br><span class="line"> 2.166750   0.917028  -0.083778</span><br><span class="line"> 2.114278   0.997652  -0.111931</span><br><span class="line"> 0.992554   2.063921  -0.056475</span><br><span class="line"> 2.117430   0.952555  -0.069985</span><br><span class="line"> 2.056150  -0.041847   0.985697</span><br><span class="line">-0.318666   1.026860   2.291806</span><br><span class="line">-0.271663   1.091503   2.180159</span><br><span class="line">-0.378276   1.142604   2.235671</span><br><span class="line">-0.221507   1.111050   2.110458</span><br><span class="line">-0.183312   2.100667   1.082645</span><br><span class="line">-0.054450   0.999278   2.055172</span><br><span class="line">-0.469778   1.178538   2.291240</span><br><span class="line">-0.057601   2.044375   1.013226</span><br><span class="line"> 2.174723   0.936981  -0.111704</span><br><span class="line">-0.133157   2.120214   1.012943</span><br><span class="line">-0.217521   2.121026   1.096495</span><br><span class="line"> 2.114278   0.997652  -0.111931</span><br><span class="line"> 2.163598   0.962125  -0.125724</span><br><span class="line">-0.210383   1.085906   2.124477</span><br><span class="line"> 2.212918   0.926599  -0.139517</span><br><span class="line">-0.133992   1.065140   2.068852</span><br><span class="line">-0.180161   1.055570   2.124590</span><br><span class="line">-0.233467   1.081121   2.152346</span><br><span class="line">-0.087824   2.074710   1.013113</span><br><span class="line">-0.203245   1.050785   2.152460</span><br><span class="line">-0.114894   1.059949   2.054945</span><br><span class="line"> 2.177874  -0.108116   0.930242</span><br><span class="line">-0.235784   2.181291   1.054492</span><br><span class="line">-0.206396   1.095882   2.110514</span><br><span class="line">-0.210383   1.085906   2.124477</span><br><span class="line">-0.029695   2.114210   0.915486</span><br><span class="line">-0.126854   1.030020   2.096834</span><br><span class="line">-0.094962   2.109831   0.985131</span><br><span class="line"> 2.105470  -0.077374   0.971904</span><br><span class="line"> 2.110292   0.987676  -0.097968</span><br><span class="line"> 2.204110  -0.148428   0.944318</span><br><span class="line">-0.203245   1.050785   2.152460</span><br><span class="line"> 2.190669   0.976887  -0.167556</span><br><span class="line">-0.160228   2.105452   1.054776</span><br><span class="line">-0.236619   1.126218   2.110401</span><br><span class="line">-0.095797   2.054758   1.041039</span><br><span class="line"> 2.113443  -0.057421   0.943978</span><br><span class="line"> 2.102319   0.967723  -0.070042</span><br><span class="line">-0.122032   2.095070   1.026963</span><br><span class="line"> 2.110292   0.987676  -0.097968</span><br><span class="line">-0.412485   1.162964   2.249521</span><br><span class="line">-0.168201   1.085499   2.082701</span><br><span class="line">-0.420458   1.143011   2.277447</span><br><span class="line">-0.248578   1.096288   2.152290</span><br><span class="line">-0.277966   2.181698   1.096268</span><br><span class="line">-0.092645   1.009660   2.082985</span><br><span class="line">-0.253400   1.031238   2.222161</span><br><span class="line">-0.053615   2.054351   0.999263</span><br><span class="line"> 2.153955  -0.167975   1.014019</span><br><span class="line">-0.122032   2.095070   1.026963</span><br><span class="line"> 2.065793   1.088253  -0.154046</span><br><span class="line">-0.110073   2.124999   0.985074</span><br><span class="line">-0.271663   1.091503   2.180159</span><br><span class="line"> 2.136527   0.947364  -0.083891</span><br><span class="line">-0.297898   1.131815   2.166083</span><br><span class="line"> 2.151639   0.932196  -0.083835</span><br><span class="line"> 2.174723   0.936981  -0.111704</span><br><span class="line">-0.111743   1.014852   2.096891</span><br><span class="line">-0.068726   2.069519   0.999207</span><br><span class="line">-0.237454   1.071144   2.166309</span><br><span class="line"> 2.121416   0.962532  -0.083948</span><br><span class="line"> 2.162763  -0.092948   0.930185</span><br><span class="line">-0.065574   1.024422   2.041152</span><br><span class="line"> 2.167585   0.972102  -0.139687</span><br><span class="line">-0.122032   2.095070   1.026963</span><br><span class="line"> 2.129389   0.982485  -0.111874</span><br><span class="line">-0.210383   1.085906   2.124477</span><br><span class="line"> 2.019625   1.078683  -0.098307</span><br><span class="line"> 2.182696   0.956934  -0.139630</span><br><span class="line">-0.161063   1.050379   2.110684</span><br><span class="line"> 2.209767   0.971696  -0.181462</span><br><span class="line">-0.038504   2.039183   0.999320</span><br><span class="line"> 2.175558   0.992055  -0.167613</span><br><span class="line">-0.110073   2.124999   0.985074</span><br><span class="line">-0.075029   2.159713   0.915316</span><br><span class="line"> 2.132541   0.937388  -0.069928</span><br><span class="line"> 2.095180   1.002844  -0.098024</span><br><span class="line"> 1.004513   2.093851  -0.098364</span><br><span class="line"> 2.243141   0.896263  -0.139403</span><br><span class="line">-0.095797   2.054758   1.041039</span><br><span class="line">-0.149103   1.080308   2.068795</span><br><span class="line"> 2.136527   0.947364  -0.083891</span><br><span class="line">-0.233467   1.081121   2.152346</span><br><span class="line">-0.072712   2.059543   1.013170</span><br><span class="line">-0.273979   2.191674   1.082305</span><br><span class="line">-0.275649   1.081527   2.194122</span><br><span class="line">-0.122032   2.095070   1.026963</span><br><span class="line"> 2.060137  -0.031871   0.971734</span><br><span class="line"> 2.076083   1.008035  -0.084118</span><br><span class="line">-0.194437   2.125811   1.068625</span><br><span class="line">-0.164214   2.095476   1.068739</span><br><span class="line">-0.344067   1.122245   2.221822</span><br><span class="line">-0.118046   2.105046   1.013000</span><br><span class="line">-0.202410   1.105859   2.096551</span><br><span class="line">-0.176174   1.065547   2.110627</span><br><span class="line">-0.247743   2.151362   1.096381</span><br><span class="line">-0.233467   1.081121   2.152346</span><br><span class="line"> 2.110292   0.987676  -0.097968</span><br></pre></td></tr></table></figure><h2 id="5-可视化展示">5. 可视化展示</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x1_min, x1_max = x[:, <span class="number">0</span>].<span class="built_in">min</span>(), x[:, <span class="number">0</span>].<span class="built_in">max</span>()   <span class="comment"># 第0列的最小值和最大值</span></span><br><span class="line">x2_min, x2_max = x[:, <span class="number">1</span>].<span class="built_in">min</span>(), x[:, <span class="number">1</span>].<span class="built_in">max</span>()   <span class="comment"># 第1列的最小值和最大值</span></span><br><span class="line">x1, x2 = np.mgrid[x1_min:x1_max:<span class="number">200j</span>, x2_min:x2_max:<span class="number">200j</span>]   <span class="comment"># 生成网格采样点</span></span><br><span class="line"></span><br><span class="line">grid_test = np.stack((x1.flat, x2.flat), axis=<span class="number">1</span>)    <span class="comment"># 分别在第0维和第2维加入数组</span></span><br><span class="line">z = clf.decision_function(grid_test)                <span class="comment"># 样本到决策面的距离</span></span><br><span class="line">grid_hat = clf.predict(grid_test)                   <span class="comment"># 预测鸢尾花类别，得到分类值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=[<span class="number">9</span>, <span class="number">6</span>])</span><br><span class="line">plt.title(<span class="string">&quot;svm in iris data classification&quot;</span>, fontsize=<span class="number">25</span>)</span><br><span class="line">tags = [<span class="string">&#x27;sepal length&#x27;</span>, <span class="string">&#x27;sepal width&#x27;</span>, <span class="string">&#x27;petal length&#x27;</span>, <span class="string">&#x27;petal width&#x27;</span>]   <span class="comment"># 特征标签</span></span><br><span class="line">plt.xlabel(tags[<span class="number">0</span>], fontsize=<span class="number">18</span>)</span><br><span class="line">plt.ylabel(tags[<span class="number">1</span>], fontsize=<span class="number">18</span>)</span><br><span class="line">plt.xlim(x1_min, x1_max)      <span class="comment"># x轴的上下限</span></span><br><span class="line">plt.ylim(x2_min, x2_max)      <span class="comment"># y轴的上下限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制背景：</span></span><br><span class="line">cm_light = ListedColormap([<span class="string">&#x27;#FFB0B0&#x27;</span>, <span class="string">&#x27;#B0FFB0&#x27;</span>, <span class="string">&#x27;#B0B0FF&#x27;</span>])   <span class="comment"># 背景颜色</span></span><br><span class="line">grid_hat = grid_hat.reshape(x1.shape)         <span class="comment"># 使得grid_hat和x1的形状一致</span></span><br><span class="line">plt.pcolormesh(x1, x2, grid_hat, cmap=cm_light)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制样本点和测试点：</span></span><br><span class="line">cm_dark = ListedColormap([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>])   <span class="comment"># 数据点颜色</span></span><br><span class="line">plt.scatter(x[:, <span class="number">0</span>], x[:, <span class="number">1</span>], c=np.squeeze(y), edgecolor=<span class="string">&#x27;k&#x27;</span>, s=<span class="number">50</span>, cmap=cm_dark)</span><br><span class="line">plt.scatter(x_test[:, <span class="number">0</span>], x_test[:, <span class="number">1</span>], s=<span class="number">120</span>, facecolor=<span class="string">&quot;none&quot;</span>, zorder=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/388e9d10720c46358a3884a1e201749a.png#pic_center" alt=""></p><hr/><blockquote><h1>写在最后</h1><ul><li>如果您发现项目存在问题，或者如果您有更好的建议，欢迎在下方评论区中留言讨论~</li><li>这是本项目的链接：<a href="https://aistudio.baidu.com/aistudio/projectdetail/709323?shared=1">实验项目 - AI Studio</a>，点击<code>fork</code>可直接在AI Studio运行~</li><li>这是我的个人主页：<a href="https://aistudio.baidu.com/aistudio/personalcenter/thirdview/118633">个人主页 - AI Studio</a>，来AI Studio互粉吧，等你哦~</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 分类问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【线性回归】商品销量预测</title>
      <link href="/2020/08/05/%E3%80%90%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E3%80%91%E5%95%86%E5%93%81%E9%94%80%E9%87%8F%E9%A2%84%E6%B5%8B/"/>
      <url>/2020/08/05/%E3%80%90%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E3%80%91%E5%95%86%E5%93%81%E9%94%80%E9%87%8F%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1>一、项目准备</h1><h2 id="1-回归问题">1. 回归问题</h2><p>回归模型可以理解为：存在一个点集，用一条曲线去拟合它分布的过程。<br>如果拟合曲线是一条直线，则称为线性回归。如果是一条二次曲线，则被称为二次回归。</p><h2 id="2-问题导入">2. 问题导入</h2><p>请根据以往在每件商品的广告费用和实际销量，预测未来商品的销量。</p><h2 id="3-数据集简介">3. 数据集简介</h2><p>数据共4列200行，每一行为一个特定的商品，前3列为输入特征，最后一列为输出特征。</p><ul><li><em>输入特征</em><br>TV：该商品用于电视上的广告费用（以千元为单位，下同）<br>Radio：在广播媒体上投资的广告费用<br>Newspaper：用于报纸媒体上的广告费用</li><li><em>输出特征</em><br>Sales：该商品的销量</li></ul><blockquote><p>这是数据集的下载链接：<a href="https://aistudio.baidu.com/aistudio/datasetdetail/48663">商品广告费与销量数据集 - AI Studio</a></p></blockquote><hr/><h1>二、实验步骤</h1><h2 id="0-导入模块-3">0.导入模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h2 id="1-数据获取">1. 数据获取</h2><ul><li><strong>获取并处理数据集</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&quot;Advertising.csv&quot;</span>)     <span class="comment"># 读取数据集</span></span><br><span class="line">x = df.drop(<span class="string">&quot;Sales&quot;</span>, axis=<span class="number">1</span>)  <span class="comment"># 提取特征值（除“Sales”外的所有字段的值）</span></span><br><span class="line">y = df[<span class="string">&quot;Sales&quot;</span>]               <span class="comment"># 提取目标值（字段“Sales”对应的字段值）</span></span><br></pre></td></tr></table></figure><ul><li><strong>数据的描述性统计分析</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.describe().T)    <span class="comment"># T代表转置矩阵</span></span><br><span class="line"><span class="comment"># 表头：特征数据个数，平均值，标准差，最小值，1/4中位数，1/2中位数，3/4中位数，最大值</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           count      mean        std  min     25%     50%      75%    max</span><br><span class="line">TV         200.0  147.0425  85.854236  0.7  74.375  149.75  218.825  296.4</span><br><span class="line">Radio      200.0   23.2640  14.846809  0.0   9.975   22.90   36.525   49.6</span><br><span class="line">Newspaper  200.0   30.5540  21.778621  0.3  12.750   25.75   45.100  114.0</span><br><span class="line">Sales      200.0   14.0225   5.217457  1.6  10.375   12.90   17.400   27.0</span><br></pre></td></tr></table></figure><ul><li><strong>数据的相关性分析</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相关系数绝对值越大，表示相关性越大；相关系数为正，表示正相关；相关系数为负，表示负相关</span></span><br><span class="line"><span class="built_in">print</span>(df.corr())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                 TV     Radio  Newspaper     Sales</span><br><span class="line">TV         1.000000  0.054809   0.056648  0.782224</span><br><span class="line">Radio      0.054809  1.000000   0.354104  0.576223</span><br><span class="line">Newspaper  0.056648  0.354104   1.000000  0.228299</span><br><span class="line">Sales      0.782224  0.576223   0.228299  1.000000</span><br></pre></td></tr></table></figure><h2 id="2-数据预处理-2">2. 数据预处理</h2><p>数据的预处理包括：数据的采样、数据的清洗、特征选择、特征降维、特征编码、规范化、数据集拆分等过程。<br>因为是已经清洗过的数据，因此我们下一步是进行训练集和测试集的划分，将整个数据集拆分成：训练集和测试集。<br>如果我们将其直接划分为训练集和数据集，那么就会造成数据分布不均的问题。好在sklearn为我们提供了划分训练集和数据集的方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[x_train, x_test,    <span class="comment"># 特征值x的训练集和测试集</span></span><br><span class="line"> y_train, y_test     <span class="comment"># 目标值y的训练集和测试集</span></span><br><span class="line">] = train_test_split(x, y, random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="3-模型训练与预测">3. 模型训练与预测</h2><ul><li><strong>构建并训练模型</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr = LinearRegression()          <span class="comment"># 采用默认参数构造模型</span></span><br><span class="line">lr.fit(x_train, y_train)         <span class="comment"># 用训练集进行模型训练</span></span><br></pre></td></tr></table></figure><ul><li><strong>进行模型预测</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr_infer = lr.predict(x_test)    <span class="comment"># 用测试集进行模型预测</span></span><br><span class="line">lr_truth = <span class="built_in">list</span>(y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Round\t Truth \t Infer&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lr_infer)):   <span class="comment"># 输出实际值和预测值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%2s\t %5.2f \t %8.5f&quot;</span> % (i+<span class="number">1</span>, lr_truth[i], lr_infer[i]))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Round Truth  Infer</span><br><span class="line"> 1 23.80  21.70910</span><br><span class="line"> 2 16.60  16.41055</span><br><span class="line"> 3  9.50   7.60955</span><br><span class="line"> 4 14.80  17.80770</span><br><span class="line"> 5 17.60  18.61464</span><br><span class="line"> 6 25.50  23.83574</span><br><span class="line"> 7 16.90  16.32489</span><br><span class="line"> 8 12.90  13.43226</span><br><span class="line"> 9 10.50   9.17173</span><br><span class="line">10 17.10  17.33385</span><br><span class="line">11 14.50  14.44479</span><br><span class="line">12 11.30   9.83512</span><br><span class="line">13 17.40  17.18798</span><br><span class="line">14 16.70  16.73087</span><br><span class="line">15 13.40  15.05529</span><br><span class="line">16 15.90  15.61434</span><br><span class="line">17 12.90  12.42542</span><br><span class="line">18 12.80  17.17716</span><br><span class="line">19  9.50  11.08828</span><br><span class="line">20 18.40  18.00538</span><br><span class="line">21 10.70   9.28439</span><br><span class="line">22 12.50  12.98458</span><br><span class="line">23  8.50   8.79951</span><br><span class="line">24 11.50  10.42382</span><br><span class="line">25 11.90  11.38465</span><br><span class="line">26 14.90  14.98083</span><br><span class="line">27 10.10   9.78853</span><br><span class="line">28 18.90  19.39643</span><br><span class="line">29 19.60  18.18100</span><br><span class="line">30 15.90  17.12808</span><br><span class="line">31 23.20  21.54670</span><br><span class="line">32 11.90  14.69809</span><br><span class="line">33 17.30  16.24641</span><br><span class="line">34 11.70  12.32115</span><br><span class="line">35 20.20  19.92423</span><br><span class="line">36 15.50  15.32499</span><br><span class="line">37 11.50  13.88727</span><br><span class="line">38 11.00  10.03162</span><br><span class="line">39 22.30  20.93106</span><br><span class="line">40  7.60   7.44937</span><br><span class="line">41  5.30   3.64696</span><br><span class="line">42  8.70   7.22020</span><br><span class="line">43  6.70   5.99628</span><br><span class="line">44 19.00  18.43382</span><br><span class="line">45  5.50   8.39408</span><br><span class="line">46 14.60  14.08371</span><br><span class="line">47 14.60  15.02196</span><br><span class="line">48 21.50  20.35836</span><br><span class="line">49 22.60  20.57036</span><br><span class="line">50 19.70  19.60637</span><br></pre></td></tr></table></figure><ul><li><strong>绘制真实值和预测值对比图</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=[<span class="number">8</span>, <span class="number">6</span>])</span><br><span class="line">plt.title(<span class="string">&quot;Commodity Sales&quot;</span>, fontsize=<span class="number">25</span>)</span><br><span class="line">x = np.arange(<span class="number">5</span>, <span class="number">25</span>)</span><br><span class="line">plt.plot(x, x)      <span class="comment"># 绘制x-y等值线</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;ground truth&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;infer result&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">plt.scatter(lr_truth, lr_infer, color=<span class="string">&quot;green&quot;</span>, label=<span class="string">&quot;sales&quot;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f62ebb662c434f29b90093cb95101995.png#pic_center" alt=""></p><h2 id="4-模型评价">4. 模型评价</h2><p>对于分类问题，评价测度是准确率，但这种方法不适用于回归问题，回归问题需要使用针对连续数值的评价测度。<br>以下三种都可以，但我们一般选用第三种方法（<strong>均方根误差，Root Mean Squared Error，RMSE</strong>）。<br><img src="https://img-blog.csdnimg.cn/e7ffb578dcaa42ada44d5fbd780442c0.jpeg#pic_center" alt=""></p><ul><li><strong>输出模型的相关信息</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cols = [<span class="string">&quot;TV&quot;</span>, <span class="string">&quot;Radio&quot;</span>, <span class="string">&quot;Newspaper&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(lr.coef_):   <span class="comment"># 输出各列的权重</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s 的权重\t %.5f&quot;</span> % (cols[i], val))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;截距\t\t %.5f&quot;</span> % lr.intercept_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练集上的评分\t %.5f&quot;</span> % lr.score(x_train, y_train))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试集上的评分\t %.5f&quot;</span> % lr.score(x_test, y_test))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TV 的权重 0.04656</span><br><span class="line">Radio 的权重 0.17916</span><br><span class="line">Newspaper 的权重 0.00345</span><br><span class="line">截距 2.87697</span><br><span class="line">训练集上的评分 0.89031</span><br><span class="line">测试集上的评分 0.91562</span><br></pre></td></tr></table></figure><ul><li><strong>输出模型的评价测度</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mae_infer = metrics.mean_absolute_error(y_test, lr_infer)   <span class="comment"># MAE：平均绝对误差</span></span><br><span class="line">mse_infer = metrics.mean_squared_error(y_test, lr_infer)    <span class="comment"># MSE：均方差</span></span><br><span class="line">rmse_infer = np.sqrt(mse_infer)                  <span class="comment"># RMSE：均方根差，即MSE的平方根</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MAE：%.6f \t MSE：%.6f \t RMSE：%.6f&quot;</span> % (mae_infer, mse_infer, rmse_infer))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAE：1.066892  MSE：1.973046  RMSE：1.404651</span><br></pre></td></tr></table></figure><h2 id="5-模型优化">5. 模型优化</h2><p>由于Newspaper和销量之间的相关性非常小 (约0.00345)，因此我们可以移除这个特征，然后看看线性回归模型预测结果的RMSE如何。</p><ul><li><strong>处理数据集</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = df[[<span class="string">&quot;TV&quot;</span>, <span class="string">&quot;Radio&quot;</span>]]    <span class="comment"># 提取新的特征值x（“TV”和“Radio”字段的值）</span></span><br><span class="line">y = df[<span class="string">&quot;Sales&quot;</span>]            <span class="comment"># 提取新的目标值y（字段“Sales”的值）</span></span><br><span class="line">[x_train, x_test,     <span class="comment"># 特征值x的训练集和测试集</span></span><br><span class="line"> y_train, y_test      <span class="comment"># 目标值y的训练集和测试集</span></span><br><span class="line">] = train_test_split(x, y, random_state=<span class="number">1</span>)   <span class="comment"># 划分训练集和测试集</span></span><br></pre></td></tr></table></figure><ul><li><strong>训练和测试模型</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nlr = LinearRegression()          <span class="comment"># 采用默认参数构建线性回归模型</span></span><br><span class="line">nlr.fit(x_train, y_train)         <span class="comment"># 用训练集进行模型训练</span></span><br><span class="line">nlr_infer = nlr.predict(x_test)   <span class="comment"># 用测试集进行模型预测</span></span><br><span class="line">nlr_truth = <span class="built_in">list</span>(y_test)          <span class="comment"># 获取实际数据</span></span><br></pre></td></tr></table></figure><ul><li><strong>绘制真实值和预测值对比图</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=[<span class="number">8</span>, <span class="number">6</span>])</span><br><span class="line">plt.title(<span class="string">&quot;Commodity Sales&quot;</span>, fontsize=<span class="number">25</span>)</span><br><span class="line">x = np.arange(<span class="number">5</span>, <span class="number">25</span>)</span><br><span class="line">plt.plot(x, x)      <span class="comment"># 绘制x-y等值线</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;ground truth&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;infer result&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">plt.scatter(lr_truth, lr_infer, <span class="number">30</span>, color=<span class="string">&quot;green&quot;</span>, label=<span class="string">&quot;old sales data&quot;</span>)</span><br><span class="line">plt.scatter(nlr_truth, nlr_infer, <span class="number">25</span>, color=<span class="string">&quot;red&quot;</span>, label=<span class="string">&quot;new sales data&quot;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/a2c5dfba6ee049079d5af8efa058d437.png#pic_center" alt=""></p><ul><li><strong>输出模型的相关信息</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vals = <span class="built_in">list</span>(nlr.coef_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;TV列的权重\t %.5f&quot;</span> % vals[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Radio列的权重\t %.5f&quot;</span> % vals[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;截距\t\t %.5f&quot;</span> % nlr.intercept_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练集上的评分\t %.5f&quot;</span> % nlr.score(x_train, y_train))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试集上的评分\t %.5f&quot;</span> % nlr.score(x_test, y_test))</span><br><span class="line"></span><br><span class="line">mse_infer = metrics.mean_squared_error(y_test, nlr_infer)  <span class="comment"># MSE：均方误差</span></span><br><span class="line">rmse_infer = np.sqrt(mse_infer)                         <span class="comment"># RMSE：均方根误差</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;评价测度(RMSE)\t %.6f&quot;</span> % rmse_infer)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TV列的权重 0.04660</span><br><span class="line">Radio列的权重 0.18118</span><br><span class="line">截距 2.92724</span><br><span class="line">训练集上的评分 0.89015</span><br><span class="line">测试集上的评分 0.91762</span><br><span class="line">评价测度(RMSE) 1.387903</span><br></pre></td></tr></table></figure><hr/><h1>三、优化结论</h1><ul><li>由上面的结果可以看出，移除相关性较弱的特征后，均方根误差RMES会变得更小一点，模型的拟合效果也会更好。</li><li>机器学习中有“奥卡姆剃刀”的原理，如果能够用简单模型解决问题，那么就不使用复杂模型，因为复杂模型往往增加了不确定性，造成过多的人力和物力成本，且容易过拟合。</li></ul><hr/><blockquote><h1>写在最后</h1><ul><li>如果您发现项目存在问题，或者如果您有更好的建议，欢迎在下方评论区中留言讨论~</li><li>这是本项目的链接：<a href="https://aistudio.baidu.com/aistudio/projectdetail/697188?shared=1">实验项目 - AI Studio</a>，点击<code>fork</code>可直接在AI Studio运行~</li><li>这是我的个人主页：<a href="https://aistudio.baidu.com/aistudio/personalcenter/thirdview/118633">个人主页 - AI Studio</a>，来AI Studio互粉吧，等你哦~</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 回归问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新冠疫情可视化分析</title>
      <link href="/2020/04/23/%E6%96%B0%E5%86%A0%E7%96%AB%E6%83%85%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90/"/>
      <url>/2020/04/23/%E6%96%B0%E5%86%A0%E7%96%AB%E6%83%85%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1>0. 项目准备</h1><ul><li><p><strong>数据可视化</strong><br>数据可视化，是一种利用计算机图形学和图像处理技术，将数据转换成图像在屏幕上显示出来，再进行交互处理的理论、方法和技术。</p></li><li><p><strong>实验要求</strong><br>本次实践基于丁香园公开的统计数据，实现新冠疫情可视化，包括疫情地图、疫情增长趋势图、疫情分布图等。<br>我们使用的数据可视化模块是Pyecharts，具体使用方法可参考&gt;&gt; <a href="https://pyecharts.org/#/zh-cn/">Pyecharts 中文手册</a></p></li><li><p><strong>安装pyecharts</strong></p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyecharts</span><br></pre></td></tr></table></figure><ul><li><strong>pyecharts 配置项</strong></li></ul><blockquote><ul><li><strong>系列配置组件</strong><br>系列配置项 set_series_opts(),可配置图元样式、文字样式、标签样式、点线样式等</li><li><strong>全局配置组件</strong><br>全局配置项 set_global_opts()，可配置标题、动画、坐标轴、图例等<br><img src="https://img-blog.csdnimg.cn/7c381070fa4c4aad9c467735d8fb0816.png#pic_center" alt=""></li></ul></blockquote><hr/><h1>1. 爬取疫情数据</h1><ul><li><strong>爬虫过程</strong><br>模拟浏览器 --&gt; 往目标站点发送请求 --&gt; 接收响应数据 --&gt; 提取有用的数据 --&gt; 保存到本地/数据库</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬取丁香园实时统计数据，保存到data目录的JSON文件中，以当前日期作为文件名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crawlCurrentData</span>():</span><br><span class="line">    resp = requests.get(<span class="string">&#x27;https://ncov.dxy.cn/ncovh5/view/pneumonia&#x27;</span>)</span><br><span class="line">    resp.encoding = resp.apparent_encoding</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        content = re.search(<span class="string">r&quot;window.getAreaStat = (.*?)&#125;]&#125;catch&quot;</span>, resp.text, re.S)</span><br><span class="line">        texts = content.group()          <span class="comment"># 获取匹配正则表达式的整体结果</span></span><br><span class="line">        string = texts.replace(<span class="string">&quot;window.getAreaStat = &quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#125;catch&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        json_data = json.loads(string)   <span class="comment"># 转化为dict类型</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data/%s.json&quot;</span> % today, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(json_data, f, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;Response [%s]&gt;: https://ncov.dxy.cn/ncovh5/view/pneumonia&#x27;</span> % resp.status_code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取各个省份的历史统计数据，保存到data目录的JSON文件中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crawlStatisticsData</span>():</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data/%s.json&quot;</span> % today, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        array = json.loads(f.read())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> province <span class="keyword">in</span> array:</span><br><span class="line">        resp = requests.get(province[<span class="string">&#x27;statisticsData&#x27;</span>])   <span class="comment"># 获取省份的历史统计数据</span></span><br><span class="line">        resp.encoding = resp.apparent_encoding</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data[province[<span class="string">&quot;provinceShortName&quot;</span>]] = json.loads(resp.text)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;&lt;Response [%s]&gt;：[%s]&#x27;</span> % (resp.status_code, province[<span class="string">&#x27;statisticsData&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data/history.json&quot;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(data, f, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">today = datetime.date.today().strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">crawlCurrentData()</span><br><span class="line">crawlStatisticsData()</span><br></pre></td></tr></table></figure><h1>2. 绘制疫情地图</h1><h2 id="2-1-全国疫情地图">2.1. 全国疫情地图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createChinaMap</span>(<span class="params">data, title</span>):    <span class="comment"># 创建中国疫情地图</span></span><br><span class="line">    <span class="comment"># (1) 创建Map对象并配置数据：</span></span><br><span class="line">    m = Map(</span><br><span class="line">        init_opts=opts.InitOpts(width=<span class="string">&#x27;1400px&#x27;</span>, height=<span class="string">&#x27;700px&#x27;</span>)   <span class="comment"># 设置图像的长和宽</span></span><br><span class="line">    )   <span class="comment"># 创建Map对象</span></span><br><span class="line">    m.add(title, [<span class="built_in">list</span>(z) <span class="keyword">for</span> z <span class="keyword">in</span> data.items()], <span class="string">&#x27;china&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (2) 设置系列配置项：</span></span><br><span class="line">    m.set_series_opts(</span><br><span class="line">        label_opts=opts.LabelOpts(font_size=<span class="number">12</span>),   <span class="comment"># 设置标签的字体样式</span></span><br><span class="line">        is_show=<span class="literal">False</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (3) 设置全局配置项：</span></span><br><span class="line">    pieces = [</span><br><span class="line">        &#123;<span class="string">&#x27;min&#x27;</span>: <span class="number">10000</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#6F171F&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;max&#x27;</span>: <span class="number">9999</span>, <span class="string">&#x27;min&#x27;</span>: <span class="number">1000</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#9c1414&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;max&#x27;</span>: <span class="number">999</span>, <span class="string">&#x27;min&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#d92727&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;max&#x27;</span>: <span class="number">499</span>, <span class="string">&#x27;min&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#E35B52&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;max&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;min&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#F39E86&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;max&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;min&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#FDEBD0&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">0</span>, <span class="string">&quot;max&quot;</span>: <span class="number">0</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#f0f0f0&quot;</span>&#125;</span><br><span class="line">    ]   <span class="comment"># 自定义每个区间的范围及其特殊样式</span></span><br><span class="line">    m.set_global_opts(</span><br><span class="line">        title_opts=opts.TitleOpts(</span><br><span class="line">            title = <span class="string">&#x27;全国%s病例分布图&#x27;</span> % title,</span><br><span class="line">            subtitle = <span class="string">&quot;更新时间：&quot;</span> + today</span><br><span class="line">        ),    <span class="comment"># 设置地图的一级标题和二级标题</span></span><br><span class="line">        legend_opts=opts.LegendOpts(is_show=<span class="literal">False</span>),  <span class="comment"># 不显示图例</span></span><br><span class="line">        visualmap_opts=opts.VisualMapOpts(</span><br><span class="line">            is_piecewise=<span class="literal">True</span>,     <span class="comment"># 分段显示数据</span></span><br><span class="line">            pieces=pieces,         <span class="comment"># 各区间的显示样式</span></span><br><span class="line">            is_show=<span class="literal">True</span>           <span class="comment"># 是否显示视觉映射配置</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (4) 保存疫情地图：</span></span><br><span class="line">    m.render(path=<span class="string">&quot;data/国内疫情地图-%s.html&quot;</span> % title)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------ 1. 读取初始数据文件 ------</span></span><br><span class="line">today = datetime.date.today().strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data/%s.json&#x27;</span> % today, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json_array = json.loads(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 2. 提取全国确诊数据 ------</span></span><br><span class="line">cn_confirm = &#123;<span class="string">&quot;count&quot;</span>: &#123;&#125;, <span class="string">&quot;current&quot;</span>: &#123;&#125;&#125;   <span class="comment"># count：累计确诊；current：现存确诊</span></span><br><span class="line"><span class="keyword">for</span> province <span class="keyword">in</span> json_array:</span><br><span class="line">    name = province[<span class="string">&quot;provinceShortName&quot;</span>]    <span class="comment"># 省级行政区名</span></span><br><span class="line">    cn_confirm[<span class="string">&quot;count&quot;</span>][name] = province[<span class="string">&quot;confirmedCount&quot;</span>]</span><br><span class="line">    <span class="comment"># cn_confirm[&quot;current&quot;][name] = province[&quot;currentConfirmedCount&quot;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;累计确诊：&quot;</span>, cn_confirm[<span class="string">&quot;count&quot;</span>])</span><br><span class="line"><span class="comment"># print(&quot;现存确诊：&quot;, cn_confirm[&quot;current&quot;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 3. 绘制全国疫情地图 ------</span></span><br><span class="line">createChinaMap(cn_confirm[<span class="string">&quot;count&quot;</span>], <span class="string">&quot;累计确诊&quot;</span>)</span><br><span class="line"><span class="comment"># createChinaMap(cn_confirm[&quot;current&quot;], &quot;现存确诊&quot;)</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">累计确诊： &#123;&#x27;香港&#x27;: 4657, &#x27;新疆&#x27;: 902, &#x27;上海&#x27;: 875, &#x27;山东&#x27;: 830, &#x27;台湾&#x27;: 487, &#x27;广东&#x27;: 1725, &#x27;陕西&#x27;: 360, &#x27;四川&#x27;: 628, &#x27;辽宁&#x27;: 261, &#x27;天津&#x27;: 216, &#x27;江苏&#x27;: 665, &#x27;浙江&#x27;: 1277, &#x27;福建&#x27;: 371, &#x27;河北&#x27;: 354, &#x27;云南&#x27;: 195, &#x27;江西&#x27;: 935, &#x27;北京&#x27;: 935, &#x27;内蒙古&#x27;: 260, &#x27;湖北&#x27;: 68139, &#x27;黑龙江&#x27;: 948, &#x27;河南&#x27;: 1276, &#x27;湖南&#x27;: 1019, &#x27;安徽&#x27;: 991, &#x27;重庆&#x27;: 583, &#x27;广西&#x27;: 255, &#x27;山西&#x27;: 201, &#x27;海南&#x27;: 171, &#x27;甘肃&#x27;: 169, &#x27;吉林&#x27;: 157, &#x27;贵州&#x27;: 147, &#x27;宁夏&#x27;: 75, &#x27;澳门&#x27;: 46, &#x27;青海&#x27;: 18, &#x27;西藏&#x27;: 1&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ad8ced28f1f642de886b574e7e66e866.jpeg#pic_center" alt=""></p><h2 id="2-2-省级疫情地图">2.2. 省级疫情地图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">formatCityName</span>(<span class="params">name, defined_cities</span>):   <span class="comment"># 规范化城市名</span></span><br><span class="line">    <span class="keyword">for</span> city <span class="keyword">in</span> defined_cities:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>((<span class="built_in">set</span>(city) &amp; <span class="built_in">set</span>(name))) == <span class="built_in">len</span>(name):</span><br><span class="line">            <span class="keyword">if</span> city.endswith(<span class="string">&quot;市&quot;</span>) <span class="keyword">or</span> city.endswith(<span class="string">&quot;区&quot;</span>) <span class="keyword">or</span> city.endswith(<span class="string">&quot;县&quot;</span>) <span class="keyword">or</span> city.endswith(<span class="string">&quot;自治州&quot;</span>):</span><br><span class="line">                <span class="keyword">return</span> city</span><br><span class="line">            <span class="keyword">return</span> city + <span class="string">&quot;市&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createProvinceMap</span>(<span class="params">data, province, title</span>):    <span class="comment"># 创建省级疫情地图</span></span><br><span class="line">    <span class="comment"># (1) 创建Map对象并配置数据：</span></span><br><span class="line">    m = Map(</span><br><span class="line">        init_opts=opts.InitOpts(width=<span class="string">&#x27;1400px&#x27;</span>, height=<span class="string">&#x27;700px&#x27;</span>)   <span class="comment"># 设置图像的长和宽</span></span><br><span class="line">    )   <span class="comment"># 创建Map对象</span></span><br><span class="line">    m.add(title, [<span class="built_in">list</span>(z) <span class="keyword">for</span> z <span class="keyword">in</span> data.items()], province)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (2) 设置系列配置项：</span></span><br><span class="line">    m.set_series_opts(</span><br><span class="line">        label_opts=opts.LabelOpts(font_size=<span class="number">12</span>),   <span class="comment"># 设置标签的字体样式</span></span><br><span class="line">        is_show=<span class="literal">False</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (3) 设置全局配置项：</span></span><br><span class="line">    pieces = [</span><br><span class="line">        &#123;<span class="string">&#x27;min&#x27;</span>: <span class="number">10000</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#6F171F&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;max&#x27;</span>: <span class="number">9999</span>, <span class="string">&#x27;min&#x27;</span>: <span class="number">1000</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#9c1414&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;max&#x27;</span>: <span class="number">999</span>, <span class="string">&#x27;min&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#d92727&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;max&#x27;</span>: <span class="number">499</span>, <span class="string">&#x27;min&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#E35B52&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;max&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;min&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#F39E86&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;max&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;min&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#FDEBD0&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">0</span>, <span class="string">&quot;max&quot;</span>: <span class="number">0</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#f0f0f0&quot;</span>&#125;</span><br><span class="line">    ]   <span class="comment"># 自定义每个区间的范围及其特殊样式</span></span><br><span class="line">    m.set_global_opts(</span><br><span class="line">        title_opts=opts.TitleOpts(</span><br><span class="line">            title = <span class="string">&#x27;%s%s病例分布图&#x27;</span> % (province, title),</span><br><span class="line">            subtitle = <span class="string">&quot;更新时间：&quot;</span> + today</span><br><span class="line">        ),    <span class="comment"># 设置地图的一级标题和二级标题</span></span><br><span class="line">        legend_opts=opts.LegendOpts(is_show=<span class="literal">False</span>),  <span class="comment"># 不显示图例</span></span><br><span class="line">        visualmap_opts=opts.VisualMapOpts(</span><br><span class="line">            is_piecewise=<span class="literal">True</span>,     <span class="comment"># 分段显示数据</span></span><br><span class="line">            pieces=pieces,         <span class="comment"># 各区间的显示样式</span></span><br><span class="line">            is_show=<span class="literal">True</span>           <span class="comment"># 是否显示视觉映射配置</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (4) 保存疫情地图：</span></span><br><span class="line">    m.render(path=<span class="string">&quot;data/%s疫情地图-%s.html&quot;</span> % (province, title))</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------ 1. 读取初始数据文件 ------</span></span><br><span class="line">today = datetime.date.today().strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data/%s.json&#x27;</span> % today, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json_list = json.loads(f.read())</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data/data24815/pycharts_city.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    defined_cities = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 2. 处理所选省份的确诊数据 ------</span></span><br><span class="line">province_name = <span class="string">&#x27;湖北&#x27;</span></span><br><span class="line">confirm = &#123;<span class="string">&quot;count&quot;</span>: &#123;&#125;, <span class="string">&quot;current&quot;</span>: &#123;&#125;&#125;   <span class="comment"># count：累计确诊；current：现存确诊</span></span><br><span class="line"><span class="keyword">for</span> province <span class="keyword">in</span> json_list:</span><br><span class="line">    <span class="keyword">if</span> province[<span class="string">&quot;provinceShortName&quot;</span>] == province_name:</span><br><span class="line">        city_array = province[<span class="string">&#x27;cities&#x27;</span>]   <span class="comment"># 获取所辖城市的疫情数据</span></span><br><span class="line">        <span class="keyword">for</span> city <span class="keyword">in</span> city_array:</span><br><span class="line">            city_name = formatCityName(city[<span class="string">&quot;cityName&quot;</span>], defined_cities)</span><br><span class="line">            confirm[<span class="string">&quot;count&quot;</span>][city_name] = city[<span class="string">&quot;confirmedCount&quot;</span>]           <span class="comment"># 累计确诊</span></span><br><span class="line">            confirm[<span class="string">&quot;current&quot;</span>][city_name] = city[<span class="string">&quot;currentConfirmedCount&quot;</span>]  <span class="comment"># 现存确诊</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s累计确诊：&quot;</span> % province_name, confirm[<span class="string">&quot;count&quot;</span>])</span><br><span class="line">        <span class="comment"># print(&quot;%s现存确诊：&quot; % province_name, confirm[&quot;current&quot;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 3. 绘制省级疫情地图 ------</span></span><br><span class="line">createProvinceMap(confirm[<span class="string">&quot;count&quot;</span>], province_name, <span class="string">&quot;累计确诊&quot;</span>)</span><br><span class="line"><span class="comment"># createProvinceMap(confirm[&quot;current&quot;], province_name, &quot;现存确诊&quot;)</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">湖北累计确诊： &#123;&#x27;武汉市&#x27;: 50344, &#x27;孝感市&#x27;: 3518, &#x27;黄冈市&#x27;: 2907, &#x27;荆州市&#x27;: 1580, &#x27;鄂州市&#x27;: 1394, &#x27;随州市&#x27;: 1307, &#x27;襄阳市&#x27;: 1175, &#x27;黄石市&#x27;: 1015, &#x27;宜昌市&#x27;: 931, &#x27;荆门市&#x27;: 928, &#x27;咸宁市&#x27;: 836, &#x27;十堰市&#x27;: 672, &#x27;仙桃市&#x27;: 575, &#x27;天门市&#x27;: 496, &#x27;恩施土家族苗族自治州&#x27;: 252, &#x27;潜江市&#x27;: 198, &#x27;神农架林区&#x27;: 11&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0482f34e6f5f4fe8bdf62c5fae337c53.jpeg#pic_center" alt=""></p><hr/><h1>3. 绘制疫情趋势图</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 1. 读取原始数据文件 ------</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data/history.json&quot;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json_dict = json.loads(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 2. 提取各省份新增确诊数据 ------</span></span><br><span class="line">history = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> province <span class="keyword">in</span> json_dict:    <span class="comment"># 提取各省份2月1日至4月7日的新增确诊数据</span></span><br><span class="line">    history[province] = []</span><br><span class="line">    <span class="keyword">for</span> day <span class="keyword">in</span> json_dict[province][<span class="string">&quot;data&quot;</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">20200201</span> &lt;= day[<span class="string">&quot;dateId&quot;</span>] &lt;= <span class="number">20200407</span>:</span><br><span class="line">            history[province].append(day[<span class="string">&quot;confirmedIncr&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 3.1.获取日期列表 ------</span></span><br><span class="line">dates = [<span class="string">&quot;%s-%s&quot;</span> % (<span class="built_in">str</span>(d[<span class="string">&quot;dateId&quot;</span>])[<span class="number">4</span>:<span class="number">6</span>], <span class="built_in">str</span>(d[<span class="string">&quot;dateId&quot;</span>])[<span class="number">6</span>:<span class="number">8</span>])</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> json_dict[<span class="string">&quot;湖北&quot;</span>][<span class="string">&quot;data&quot;</span>] <span class="keyword">if</span> <span class="number">20200201</span>&lt;=d[<span class="string">&quot;dateId&quot;</span>]&lt;=<span class="number">20200407</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 3.2.提取全国新增确诊数据 ------</span></span><br><span class="line">cn_history = np.array([<span class="number">0</span>] * <span class="built_in">len</span>(dates))   <span class="comment"># 初始化一个长度为len(dates)的数组</span></span><br><span class="line"><span class="keyword">for</span> province <span class="keyword">in</span> history:</span><br><span class="line">    cn_history += np.array(history[province])</span><br><span class="line">cn_history = cn_history.tolist()   <span class="comment"># 将numpy数组转化成列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 3.3.提取湖北及其他省份的数据 ------</span></span><br><span class="line">hb_history = history[<span class="string">&quot;湖北&quot;</span>]</span><br><span class="line">ot_history = [cn_history[i]-hb_history[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dates))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 4. 绘制新增确诊趋势图 ------</span></span><br><span class="line">line = Line(</span><br><span class="line">    init_opts=opts.InitOpts(width=<span class="string">&#x27;1500px&#x27;</span>, height=<span class="string">&#x27;700px&#x27;</span>)  <span class="comment"># 设置图像的长和宽</span></span><br><span class="line">)                         <span class="comment"># 创建Line对象</span></span><br><span class="line">line.add_xaxis(dates)     <span class="comment"># 添加横轴数据</span></span><br><span class="line">line.add_yaxis(</span><br><span class="line">    <span class="string">&quot;全国新增确诊病例&quot;</span>, cn_history, is_smooth=<span class="literal">True</span>,      <span class="comment"># 图例、数据、是否平滑曲线</span></span><br><span class="line">    linestyle_opts=opts.LineStyleOpts(width=<span class="number">3</span>, color=<span class="string">&quot;#B44038&quot;</span>),  <span class="comment"># 线条样式配置项</span></span><br><span class="line">    itemstyle_opts=opts.ItemStyleOpts(</span><br><span class="line">        color=<span class="string">&#x27;#B44038&#x27;</span>, border_color=<span class="string">&quot;#B44038&quot;</span>, border_width=<span class="number">6</span></span><br><span class="line">    )   <span class="comment"># 图元样式设置项</span></span><br><span class="line">)</span><br><span class="line">line.add_yaxis(</span><br><span class="line">    <span class="string">&quot;湖北新增确诊病例&quot;</span>, hb_history, is_smooth=<span class="literal">True</span>,</span><br><span class="line">    linestyle_opts=opts.LineStyleOpts(width=<span class="number">2</span>, color=<span class="string">&quot;#4E87ED&quot;</span>),</span><br><span class="line">    label_opts=opts.LabelOpts(position=<span class="string">&quot;bottom&quot;</span>),    <span class="comment"># 设置数据标签的位置</span></span><br><span class="line">    itemstyle_opts=opts.ItemStyleOpts(</span><br><span class="line">        color=<span class="string">&quot;#4E87ED&quot;</span>, border_color=<span class="string">&quot;#4E87ED&quot;</span>, border_width=<span class="number">4</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">line.add_yaxis(</span><br><span class="line">    <span class="string">&quot;其他省份新增确诊&quot;</span>, ot_history, is_smooth=<span class="literal">True</span>,</span><br><span class="line">    linestyle_opts=opts.LineStyleOpts(width=<span class="number">2</span>, color=<span class="string">&quot;#F1A846&quot;</span>),</span><br><span class="line">    label_opts=opts.LabelOpts(position=<span class="string">&quot;bottom&quot;</span>),</span><br><span class="line">    itemstyle_opts=opts.ItemStyleOpts(</span><br><span class="line">        color=<span class="string">&quot;#F1A846&quot;</span>, border_color=<span class="string">&quot;#F1A846&quot;</span>, border_width=<span class="number">4</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">line.set_global_opts(</span><br><span class="line">    title_opts=opts.TitleOpts(title=<span class="string">&quot;新增确诊趋势图&quot;</span>, subtitle=<span class="string">&quot;数据来源：丁香园&quot;</span>),</span><br><span class="line">    yaxis_opts=opts.AxisOpts(</span><br><span class="line">        max_=<span class="number">16000</span>, min_=<span class="number">1</span>, type_=<span class="string">&quot;log&quot;</span>,                  <span class="comment"># 坐标轴配置项</span></span><br><span class="line">        splitline_opts=opts.SplitLineOpts(is_show=<span class="literal">True</span>),  <span class="comment"># 分割线配置项</span></span><br><span class="line">        axisline_opts=opts.AxisLineOpts(is_show=<span class="literal">True</span>)     <span class="comment"># 坐标轴刻度线配置项</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">line.render(<span class="string">&quot;data/国内新增确诊数趋势图.html&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/46f5fe2ffe004d6985e0194013b93bba.jpeg#pic_center" alt=""></p><hr/><h1>4. 绘制疫情分布饼图</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Pie</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createPieGraph</span>(<span class="params">data, title</span>):</span><br><span class="line">    pie = Pie(</span><br><span class="line">        init_opts=opts.InitOpts(width=<span class="string">&#x27;900px&#x27;</span>, height=<span class="string">&#x27;600px&#x27;</span>)  <span class="comment"># 设置图像的长和宽</span></span><br><span class="line">    )    <span class="comment"># 创建Pie对象</span></span><br><span class="line">    data_pair = [<span class="built_in">list</span>(z) <span class="keyword">for</span> z <span class="keyword">in</span> data.items()]</span><br><span class="line">    data_pair.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    pie.add(title, data_pair,</span><br><span class="line">            center=[<span class="string">&quot;45%&quot;</span>, <span class="string">&quot;65%&quot;</span>],  <span class="comment"># 饼图圆心坐标：前者相对于宽度，后者相对于高度</span></span><br><span class="line">            radius=<span class="string">&quot;180&quot;</span>)           <span class="comment"># 饼图的半径</span></span><br><span class="line">    pie.set_series_opts(</span><br><span class="line">        label_opts=opts.LabelOpts(formatter=<span class="string">&quot;&#123;b&#125;: &#123;c&#125;&quot;</span>,   <span class="comment"># 标签格式</span></span><br><span class="line">                                  font_size=<span class="number">15</span>)           <span class="comment"># 字体大小</span></span><br><span class="line">    )   <span class="comment"># 系列配置项</span></span><br><span class="line">    pie.set_global_opts(</span><br><span class="line">        title_opts=opts.TitleOpts(title=<span class="string">&quot;国内%s分布饼图&quot;</span> % title,</span><br><span class="line">                                  subtitle=<span class="string">&quot;更新时间：%s&quot;</span> % today),   <span class="comment"># 设置标题</span></span><br><span class="line">        legend_opts=opts.LegendOpts(pos_top=<span class="string">&quot;20%&quot;</span>,       <span class="comment"># 图例离顶部的距离</span></span><br><span class="line">                                    pos_left=<span class="string">&quot;80%&quot;</span>,      <span class="comment"># 图例离左侧的距离</span></span><br><span class="line">                                    orient=<span class="string">&quot;vertical&quot;</span>)   <span class="comment"># 图例的布局朝向</span></span><br><span class="line">    )   <span class="comment"># 全局配置项</span></span><br><span class="line">    pie.render(<span class="string">&quot;data/国内%s分布饼图.html&quot;</span> % title)   <span class="comment"># 保存图像至文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------ 1. 读取原始数据文件 ------</span></span><br><span class="line">today = datetime.date.today().strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data/%s.json&quot;</span> % today, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json_list = json.loads(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 2. 提取全国确诊数据 ------</span></span><br><span class="line">cn_confirm = &#123;<span class="string">&quot;count&quot;</span>: &#123;&#125;, <span class="string">&quot;current&quot;</span>: &#123;&#125;&#125;   <span class="comment"># count：累计确诊；current：现存确诊</span></span><br><span class="line"><span class="keyword">for</span> province <span class="keyword">in</span> json_array:</span><br><span class="line">    name = province[<span class="string">&quot;provinceShortName&quot;</span>]    <span class="comment"># 省级行政区名</span></span><br><span class="line">    cn_confirm[<span class="string">&quot;count&quot;</span>][name] = province[<span class="string">&quot;confirmedCount&quot;</span>]</span><br><span class="line">    <span class="comment"># cn_confirm[&quot;current&quot;][name] = province[&quot;currentConfirmedCount&quot;]</span></span><br><span class="line"><span class="comment"># print(&quot;累计确诊：&quot;, cn_confirm[&quot;count&quot;])</span></span><br><span class="line"><span class="comment"># print(&quot;现存确诊：&quot;, cn_confirm[&quot;current&quot;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ 3. 绘制疫情分布饼图 ------</span></span><br><span class="line">createPieGraph(cn_confirm[<span class="string">&quot;count&quot;</span>], <span class="string">&quot;累计确诊&quot;</span>)</span><br><span class="line"><span class="comment"># createPieGraph(cn_confirm[&quot;current&quot;], &quot;现存确诊&quot;)</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/21d9b46741a54ec48802b3a5c53d679d.jpeg#pic_center" alt=""></p><hr/><blockquote><h1>写在最后</h1><ul><li>如果您发现项目存在问题，或者如果您有更好的建议，欢迎在下方评论区中留言讨论~</li><li>这是本项目的链接：<a href="https://aistudio.baidu.com/aistudio/projectdetail/746534?shared=1">实验项目 - AI Studio</a>，点击<code>fork</code>可直接在AI Studio运行~</li><li>这是我的个人主页：<a href="https://aistudio.baidu.com/aistudio/personalcenter/thirdview/118633">个人主页 - AI Studio</a>，来AI Studio互粉吧，等你哦~</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的内部排序算法</title>
      <link href="/2020/02/09/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/09/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1>一、算法概述</h1><h2 id="1-基本概念">1. 基本概念</h2><p>（1）外部排序和内部排序</p><blockquote><ul><li><strong>内部排序</strong>：指在排序期间数据对象所有存放在内存的排序。<strong>（本文所讨论的都是内部排序算法）</strong></li><li><strong>外部排序</strong>：指在排序期间所有对象占用的空间太大，以致于不能在同一时间内存放在内存中，这些对象必须依据排序过程，不断在内、外存间移动已完成外部排序。</li></ul></blockquote><p>（2）排序算法的稳定性</p><blockquote><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li></ul></blockquote><p>（3）算法的时空复杂度</p><blockquote><ul><li><strong>时间复杂度</strong> 是指执行算法所需要的计算工作量。</li><li><strong>空间复杂度</strong> 是指执行这个算法所需要的内存空间。</li></ul></blockquote><h2 id="2-算法分类-2">2. 算法分类</h2><p>常见排序算法可以分为两大类：</p><blockquote><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/20210209160011642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RYS19LZXZpbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="3-算法复杂度">3. 算法复杂度</h2><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最好时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(n \log_2^n)</td><td>O(n \log_2^n)</td><td>O(n^2)</td><td>O(\log_2^n)</td><td>不稳定</td></tr><tr><td>直接选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(n \log_2^n)</td><td>O(n \log_2^n)</td><td>O(n \log_2^n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>直接插入排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>折半插入排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n^1.3)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(n \log_2^n)</td><td>O(n \log_2^n)</td><td>O(n \log_2^n)</td><td>O(n)</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n+k)</td><td>稳定</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n^2)</td><td>O(n+k)</td><td>稳定</td></tr></tbody></table><hr/><h1>二、算法实现</h1><p>注：本文使用<strong>Python</strong>来实现以下几种排序算法。其中，调用random.randint()方法的目的是产生初始随机序列以供排序。</p><h2 id="1-交换排序">1. 交换排序</h2><h3 id="1-1-冒泡排序（Bubble-Sort）">1.1. 冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法，它的基本思想是：重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来；走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p><p>（1）算法思路：</p><blockquote><p>（1）比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>（2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>（3）针对所有的元素重复以上的步骤，除了最后一个；<br>（4）重复步骤①②③，直到排序完成。</p></blockquote><p>（2）算法实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubbleSort</span>(<span class="params">numList</span>):    <span class="comment"># 冒泡排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numList)-<span class="number">1</span>):</span><br><span class="line">        isSorted = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numList)-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> numList[j]&gt;numList[j+<span class="number">1</span>]:</span><br><span class="line">                numList[j], numList[j+<span class="number">1</span>] = numList[j+<span class="number">1</span>], numList[j]</span><br><span class="line">                isSorted = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> isSorted==<span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">break</span>   <span class="comment"># 若一轮排序后仍不发生元素交换，则说明排序已完成</span></span><br><span class="line">    <span class="keyword">return</span> numList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numList = [randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;冒泡排序前：&quot;</span>, numList)</span><br><span class="line">    numList = bubbleSort(numList)   <span class="comment"># 冒泡排序</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;冒泡排序后：&quot;</span>, numList)</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">冒泡排序前： [73, 21, 53, 76, 62, 35, 59, 21, 19, 43]</span><br><span class="line">冒泡排序后： [19, 21, 21, 35, 43, 53, 59, 62, 73, 76]</span><br></pre></td></tr></table></figure><h3 id="1-2-快速排序（Quick-Sort）">1.2. 快速排序（Quick Sort）</h3><p>快速排序由C. A. R. Hoare在1960年提出，是对冒泡排序算法的一种改进，它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>（1）算法思路：</p><blockquote><p>（1）从数列中挑出一个元素，称为 “基准”；<br>（2）重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>（3）递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></blockquote><p>（2）算法实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">numList, left, right</span>):</span><br><span class="line">    standard = numList[left]</span><br><span class="line">    <span class="keyword">while</span> left&lt;right :</span><br><span class="line">        <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> standard&lt;=numList[right] :</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left&lt;right <span class="keyword">and</span> standard&gt;numList[right] :</span><br><span class="line">            numList[left] = numList[right]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> standard&gt;=numList[left] :</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left&lt;right <span class="keyword">and</span> standard&lt;numList[left] :</span><br><span class="line">            numList[right] = numList[left]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    numList[left] = standard</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">numList, left, right</span>):    <span class="comment"># 快速排序</span></span><br><span class="line">    <span class="keyword">if</span> left&lt;right :</span><br><span class="line">        mid = partition(numList, left, right)</span><br><span class="line">        numList = quickSort(numList, left, mid-<span class="number">1</span>)</span><br><span class="line">        numList = quickSort(numList, mid+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> numList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numList = [randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;快速排序前：&quot;</span>, numList)</span><br><span class="line">    numList = quickSort(numList, <span class="number">0</span>, <span class="built_in">len</span>(numList)-<span class="number">1</span>)     <span class="comment"># 快速排序</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;快速排序后：&quot;</span>, numList)</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">快速排序前： [87, 57, 15, 93, 88, 100, 13, 18, 7, 67]</span><br><span class="line">快速排序后： [7, 13, 15, 18, 57, 67, 87, 88, 93, 100]</span><br></pre></td></tr></table></figure><h2 id="2-选择排序">2. 选择排序</h2><h3 id="2-1-直接选择排序（Straight-Selection-Sort）">2.1. 直接选择排序（Straight Selection Sort）</h3><p>直接 (简单) 选择排序是一个简单直观的选择排序算法，它的基本思想是：在待排记录中依次选择关键字最小的记录作为有序序列的最后一条记录，逐渐缩小范围，直至全部记录选择完毕。</p><p>（1）算法思路：</p><blockquote><p>（1）设array一个需要排序的数组，最初时的未排序序列unsortedArray为整个数组array。<br>（2）首先从前向后扫描整个未排序序列，在未排序序列中找到最小元素，与该序列的首元素进行交换。每次遍历后，未排序序列中的最小元素将被移动到已排序序列末尾，并且已确定位置的数据不需要再参与排序，这样一来就缩小了未排序序列unsortedArray。<br>（3）重复步骤②，直到所有元素均排序完毕。</p></blockquote><p>（2）算法实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selectSort</span>(<span class="params">numList</span>):    <span class="comment"># 简单选择排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numList)-<span class="number">1</span>):</span><br><span class="line">        index = i   <span class="comment"># 指向待排序序列中最小元素的下标</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(numList)):</span><br><span class="line">            <span class="keyword">if</span> numList[index]&gt;numList[j]:</span><br><span class="line">                index = j</span><br><span class="line">        numList[index], numList[i] = numList[i], numList[index]      </span><br><span class="line">    <span class="keyword">return</span> numList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numList = [randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;简单选择排序前：&quot;</span>, numList)</span><br><span class="line">    numList = selectSort(numList)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;简单选择排序后：&quot;</span>, numList)</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单选择排序前： [52, 2, 25, 77, 80, 52, 51, 67, 72, 0]</span><br><span class="line">简单选择排序后： [0, 2, 25, 51, 52, 52, 67, 72, 77, 80]</span><br></pre></td></tr></table></figure><h3 id="2-2-堆排序（Heap-Sort）">2.2. 堆排序（Heap Sort）</h3><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>（1）算法思路：</p><blockquote><p>（1）将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>（2）将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>（3）由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p></blockquote><p>（2）算法实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxHeapify</span>(<span class="params">heap, start, end</span>):</span><br><span class="line">    parent, son = start, start*<span class="number">2</span> + <span class="number">1</span>    <span class="comment"># 设置初始值</span></span><br><span class="line">    <span class="keyword">while</span> son&lt;=end :</span><br><span class="line">        <span class="keyword">if</span> son&lt;end <span class="keyword">and</span> heap[son]&lt;heap[son+<span class="number">1</span>] :</span><br><span class="line">            son += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> heap[son]&lt;=heap[parent] :</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        heap[parent], heap[son] = heap[son], heap[parent]</span><br><span class="line">        parent, son = son, <span class="number">2</span>*son + <span class="number">1</span>    <span class="comment"># 更新数据值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapSort</span>(<span class="params">heap</span>):     <span class="comment"># 堆排序</span></span><br><span class="line">    size = <span class="built_in">len</span>(heap)</span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(size//<span class="number">2</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        maxHeapify(heap, start-<span class="number">1</span>, size-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(size-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        heap[<span class="number">0</span>], heap[end] = heap[end], heap[<span class="number">0</span>]</span><br><span class="line">        maxHeapify(heap, <span class="number">0</span>, end-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numList = [randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;堆排序前：&quot;</span>, numList)</span><br><span class="line">    numList = heapSort(numList)   <span class="comment"># 堆排序</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;堆排序后：&quot;</span>, numList)</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">堆排序前： [52, 50, 6, 80, 1, 88, 28, 81, 25, 51]</span><br><span class="line">堆排序后： [1, 6, 25, 28, 50, 51, 52, 80, 81, 88]</span><br></pre></td></tr></table></figure><h2 id="3-插入排序">3. 插入排序</h2><h3 id="3-1-直接插入排序（Straight-Insertion-Sort）">3.1. 直接插入排序（Straight Insertion Sort）</h3><p>直接插入排序是一种最简单的排序方法，其基本操作是将一条记录插入到已排好的有序表中，从而得到一个新的有序表。</p><p>（1）算法思路：</p><blockquote><p>（1）从第一个元素开始，该元素可以认为已经被排序；<br>（2）取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>（3）如果该已排序元素大于新元素，将该元素移到下一位置；<br>（4）重复步骤③，直到找到已排序的元素小于或者等于新元素的位置；<br>（5）将新元素插入到该位置后；<br>（6）重复步骤②~⑤，直到排序完成。</p></blockquote><p>（2）算法实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertSort</span>(<span class="params">numList</span>):    <span class="comment"># 直接插入排序</span></span><br><span class="line">    <span class="keyword">for</span> no <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(numList)):</span><br><span class="line">        index = no - <span class="number">1</span>      <span class="comment"># 指向当前插入点</span></span><br><span class="line">        num = numList[no]   <span class="comment"># 当前待插入的元素</span></span><br><span class="line">        <span class="keyword">while</span> index&gt;=<span class="number">0</span> <span class="keyword">and</span> numList[index]&gt;num :</span><br><span class="line">            numList[index+<span class="number">1</span>] = numList[index]</span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        numList[index+<span class="number">1</span>] = num</span><br><span class="line">    <span class="keyword">return</span> numList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numList = [randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;直接插入排序前：&quot;</span>, numList)</span><br><span class="line">    numList = insertSort(numList)   <span class="comment"># 直接插入排序</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;直接插入排序后：&quot;</span>, numList)</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直接插入排序前： [57, 65, 35, 11, 39, 10, 13, 10, 67, 72]</span><br><span class="line">直接插入排序后： [10, 10, 11, 13, 35, 39, 57, 65, 67, 72]</span><br></pre></td></tr></table></figure><h3 id="3-2-折半插入排序（Binary-Insertion-Sort）">3.2. 折半插入排序（Binary Insertion Sort）</h3><p>折半插入排序是对直接插入排序算法的一种改进，由于排序过程就是不断的依次将元素插入前面已排好序的序列中，并且数列的前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。</p><p>（1）算法思路：</p><blockquote><p>（1）设现有一个数组a需要排序，从第一个元素开始，该元素可以认为已经被排序；<br>（2）将待插入区域的首元素下标为 left，末元素下标记为 right，mid = (left+right)/2；取出下一个元素next，比较 next 和 a[mid] 的大小；<br>（3）如果 next 大于 a[mid]，选择 a[mid+1] 到 a[right] 为新的插入区域（即令 left = mid+1 ）；否则选择a[left]到a[m-1]为新的插入区域(即令 right = mid-1 )；<br>（4）重复步骤③，直至 left &gt; right 为止，接着将 right 位置之后所有元素向后移一位，并将新元素next插入 a[high+1]；<br>（5）重复步骤②③④，直到排序完成。</p></blockquote><p>（2）算法实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertSort</span>(<span class="params">numList</span>):    <span class="comment"># 折半插入排序</span></span><br><span class="line">    <span class="keyword">for</span> no <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numList)):</span><br><span class="line">        num = numList[no]   <span class="comment"># 当前待插入的元素</span></span><br><span class="line">        <span class="comment"># left、right代表已排序的序列的首、尾元素下标</span></span><br><span class="line">        left, right = <span class="number">0</span>, no-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 找到插入点的下标</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numList[mid]&gt;num :</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 插入数据</span></span><br><span class="line">        index = no - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> index&gt;=left:</span><br><span class="line">            numList[index+<span class="number">1</span>] = numList[index]</span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        numList[index+<span class="number">1</span>] = num</span><br><span class="line">    <span class="keyword">return</span> numList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numList = [randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;折半插入排序前：&quot;</span>, numList)</span><br><span class="line">    numList = insertSort(numList)   <span class="comment"># 折半插入排序</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;折半插入排序后：&quot;</span>, numList)</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">折半插入排序前： [59, 15, 29, 0, 89, 45, 25, 26, 51, 86]</span><br><span class="line">折半插入排序后： [0, 15, 25, 26, 29, 45, 51, 59, 86, 89]</span><br></pre></td></tr></table></figure><h3 id="3-3-希尔排序（Shell-Sort）">3.3. 希尔排序（Shell Sort）</h3><p>希尔排序，又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法，该方法因 D.L.Shell 于 1959 年提出而得名。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。</p><p>（1）算法思路：</p><blockquote><p>设现有一个待排序数组，span（初值为数组长度的一半）为增量值：<br>（1）根据增量值span把整个数组划分为span个子序列（其中，每个子数组相邻俩元素的下标相差span，然后对各个子序列进行直接插入排序，接着将span缩小为原来的一半。<br>（2）重复步骤①，直到span小于1。</p></blockquote><p>（2）算法实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shellSort</span>(<span class="params">numList</span>):     <span class="comment"># 希尔排序</span></span><br><span class="line">    span = <span class="built_in">len</span>(numList)//<span class="number">2</span>  <span class="comment"># 跨度值</span></span><br><span class="line">    <span class="keyword">while</span> span&gt;=<span class="number">1</span> :</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(span, <span class="built_in">len</span>(numList)):</span><br><span class="line">            temp = numList[i]   <span class="comment"># 当前待排序的元素</span></span><br><span class="line">            index = i - span    <span class="comment"># 已排序序列尾元素的下标</span></span><br><span class="line">            <span class="keyword">while</span> index&gt;=<span class="number">0</span> <span class="keyword">and</span> numList[index]&gt;temp :</span><br><span class="line">                numList[index + span] = numList[index]</span><br><span class="line">                index -= span</span><br><span class="line">            numList[index + span] = temp</span><br><span class="line">        span //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> numList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numList = [randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;希尔排序前：&quot;</span>, numList)</span><br><span class="line">    numList = shellSort(numList)    <span class="comment"># 希尔排序</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;希尔排序后：&quot;</span>, numList)</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">希尔排序前： [25, 64, 87, 3, 20, 92, 96, 6, 35, 51]</span><br><span class="line">希尔排序后： [3, 6, 20, 25, 35, 51, 64, 87, 92, 96]</span><br></pre></td></tr></table></figure><h2 id="4-归并排序">4. 归并排序</h2><h3 id="4-1-二路归并排序（Binary-Merge-Sort）">4.1. 二路归并排序（Binary Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法，它是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>（1）算法思路：</p><blockquote><p>（1）设现有一个待排序数组，将数组均分成左部子数组left和右部子数组right。如果子数组内部数据是无序的，则对子数组递归进行二分，直至分解出的小组只有一个元素，此时认为该小组内部有序。<br>（2）合并两个有序子数组，比较两个子数组的最前面的数，谁小就先取谁，该数组的指针往后移一位。<br>（3）重复步骤②，直至一个数组为空，然后把另一个数组的剩余部分复制过来即可。<br>（4）重复步骤②③，直至所有子数组归并成一个数组。</p></blockquote><p>（2）算法实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Merge</span>(<span class="params">left, right</span>):    <span class="comment"># 归并序列</span></span><br><span class="line">    result = []</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(left) <span class="keyword">and</span> j&lt;<span class="built_in">len</span>(right) :</span><br><span class="line">        <span class="keyword">if</span> left[i]&lt;right[j] :</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i&lt;<span class="built_in">len</span>(left):</span><br><span class="line">        result.extend(left[i : ])</span><br><span class="line">    <span class="keyword">if</span> j&lt;<span class="built_in">len</span>(right):</span><br><span class="line">        result.extend(right[j : ])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeSort</span>(<span class="params">numList</span>):   <span class="comment"># 二路归并排序</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(numList)&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> numList</span><br><span class="line">    size = (<span class="built_in">len</span>(numList)) // <span class="number">2</span></span><br><span class="line">    left = mergeSort(numList[:size])</span><br><span class="line">    right = mergeSort(numList[size:])</span><br><span class="line">    result = Merge(left, right)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numList = [randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;二路归并排序前：&quot;</span>, numList)</span><br><span class="line">    numList = mergeSort(numList)       <span class="comment"># 二路归并排序</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;二路归并排序后：&quot;</span>, numList)</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二路归并排序前： [46, 77, 12, 91, 78, 6, 100, 86, 60, 2]</span><br><span class="line">二路归并排序后： [2, 6, 12, 46, 60, 77, 78, 86, 91, 100]</span><br></pre></td></tr></table></figure><h2 id="5-非比较类排序">5. 非比较类排序</h2><h3 id="5-1-基数排序（Radix-Sort）">5.1. 基数排序（Radix Sort）</h3><p>基数排序属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort 或 bin sort），顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog®m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p><p>（1）算法思路：</p><blockquote><p>（1）将所有待比较的整数统一为同样的数位长度，数位较短的数前面补零；<br>（2）从最低位开始，依次进行一次排序；<br>（3）从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p></blockquote><p>（2）算法实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">radixSort</span>(<span class="params">numList</span>):     <span class="comment"># 基数排序</span></span><br><span class="line">    <span class="comment"># (1) 找出最大值并求出其位数：</span></span><br><span class="line">    max_digit, maxium = <span class="number">1</span>, <span class="built_in">max</span>(numList)</span><br><span class="line">    <span class="keyword">while</span> maxium &gt;= <span class="number">10</span>**max_digit:</span><br><span class="line">        max_digit += <span class="number">1</span></span><br><span class="line">    <span class="comment"># (2) 从个位开始，每研究一个数位就进行一次排序：</span></span><br><span class="line">    digit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> digit &lt; max_digit:</span><br><span class="line">        cur, temp = <span class="number">0</span>, <span class="number">10</span>**digit</span><br><span class="line">        table = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>)]     <span class="comment"># 记录某位出现-9~9的整数</span></span><br><span class="line">        <span class="comment"># (2-1) 根据整数某位的取值对号入座：</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numList:</span><br><span class="line">            <span class="comment"># （因为余数始终为正数，这里需讨论正负性）</span></span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">0</span>:</span><br><span class="line">                index = num // temp % <span class="number">10</span> + <span class="number">9</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = <span class="number">9</span> - (-num) // temp % <span class="number">10</span></span><br><span class="line">            table[index].append(num)</span><br><span class="line">        <span class="comment"># (2-2) 重新写回原数组，完成一次排序：</span></span><br><span class="line">        <span class="keyword">for</span> lt <span class="keyword">in</span> table:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> lt:</span><br><span class="line">                numList[cur] = num</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">        digit += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> numList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numList = [randint(-<span class="number">200</span>, <span class="number">200</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;基数排序前：&quot;</span>, numList)</span><br><span class="line">    numList = radixSort(numList)       <span class="comment"># 基数排序</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;基数排序后：&quot;</span>, numList)</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基数排序前： [-46, 45, 32, -92, 18, 52, -31, -9, -50, -132]</span><br><span class="line">基数排序后： [-92, -50, -46, -132, -31, -9, 18, 32, 45, 52]</span><br></pre></td></tr></table></figure><h3 id="5-2-计数排序（Counting-Sort）">5.2. 计数排序（Counting Sort）</h3><p>计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，它的时间复杂度（Ο(n+k)，其中k是待排序整数的范围）是低于任何比较排序算法。 当然这是一种牺牲空间换取时间的做法，而且当O(k) &gt; O(n*log(n))的时候其效率反而不如基于比较的排序。</p><p>（1）算法思路：</p><blockquote><p>（1）找出待排序的数组中最大和最小的元素；<br>（2）统计数组中介于最值之间的每个值的元素出现的次数；<br>（3）依据统计的出现次数将数值反向填充目标数组。</p></blockquote><p>（2）算法实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countingSort</span>(<span class="params">numList</span>):</span><br><span class="line">    <span class="comment"># (1) 找出数组numList中的最值：</span></span><br><span class="line">    maxium, minium = <span class="built_in">max</span>(numList), <span class="built_in">min</span>(numList)</span><br><span class="line">    <span class="comment"># (2) 建立一个列表统计最值间每个整数出现的次数：</span></span><br><span class="line">    tabLen = maxium - minium + <span class="number">1</span></span><br><span class="line">    table = [<span class="number">0</span>] * tabLen</span><br><span class="line">    <span class="comment"># (3) 统计最值间每个整数出现的次数：</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> numList:</span><br><span class="line">        index = num - minium    <span class="comment"># 找出num对应的容器下标</span></span><br><span class="line">        table[index] += <span class="number">1</span>       <span class="comment"># num出现的次数加 1</span></span><br><span class="line">    <span class="comment"># (4) 反向填充目标数组：</span></span><br><span class="line">    cur = <span class="number">0</span>                 <span class="comment"># 当前应填充的数组元素下标</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(tabLen):</span><br><span class="line">        <span class="keyword">while</span> table[idx] &gt; <span class="number">0</span>:</span><br><span class="line">            numList[cur] = idx + minium</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">            table[idx] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> numList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numList = [randint(-<span class="number">200</span>, <span class="number">200</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;计数排序前：&quot;</span>, numList)</span><br><span class="line">    numList = countingSort(numList)       <span class="comment"># 计数排序</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;计数排序后：&quot;</span>, numList)</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计数排序前： [-32, 71, -86, 61, -123, 7, -138, -188, 49, 150]</span><br><span class="line">计数排序后： [-188, -138, -123, -86, -32, 7, 49, 61, 71, 150]</span><br></pre></td></tr></table></figure><h3 id="5-3-桶排序（Bucket-Sort）">5.3. 桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><p>（1）算法思路：</p><blockquote><p>（1）设置固定数量的空桶；<br>（2）把数据放到对应的桶中；<br>（3）对每个不为空的桶中数据进行排序；<br>（4）拼接不为空的桶中数据，得到结果。</p></blockquote><p>（2）算法实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertionSort</span>(<span class="params">array</span>):   <span class="comment"># 直接插入排序</span></span><br><span class="line">    <span class="keyword">for</span> no <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(array)):</span><br><span class="line">        cur = no - <span class="number">1</span>        <span class="comment"># 指向当前插入点</span></span><br><span class="line">        num = array[no]     <span class="comment"># 当前待插入的元素</span></span><br><span class="line">        <span class="keyword">while</span> cur &gt;= <span class="number">0</span> <span class="keyword">and</span> array[cur] &gt; num:</span><br><span class="line">            array[cur+<span class="number">1</span>] = array[cur]</span><br><span class="line">            cur -= <span class="number">1</span></span><br><span class="line">        array[cur+<span class="number">1</span>] = num</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bucketSort</span>(<span class="params">numList</span>):</span><br><span class="line">    <span class="comment"># (1) 设置桶的数量（默认为5）：</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(numList) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    bucketNum = <span class="number">5</span> <span class="keyword">if</span> <span class="built_in">len</span>(numList) &gt; <span class="number">5</span> <span class="keyword">else</span> <span class="built_in">len</span>(numList)</span><br><span class="line">    bucketList = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bucketNum)]</span><br><span class="line">    <span class="comment"># (2) 找出数组numList中的最值，设置好桶内间隔：</span></span><br><span class="line">    maxium, minium = <span class="built_in">max</span>(numList), <span class="built_in">min</span>(numList)</span><br><span class="line">    gap = (maxium - minium)//bucketNum + <span class="number">1</span>  <span class="comment"># 桶内数字的间隔</span></span><br><span class="line">    <span class="comment"># (3) 将数字装入桶中：</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> numList:</span><br><span class="line">        index = (num - minium)//gap   <span class="comment"># 获取num所属桶的编号</span></span><br><span class="line">        bucketList[index].append(num)</span><br><span class="line">    <span class="comment"># (4) 为每个桶里面的数字进行排序：</span></span><br><span class="line">    cur = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> bucketList:</span><br><span class="line">        bucket = insertionSort(bucket)  <span class="comment"># 插入排序</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> bucket:</span><br><span class="line">            numList[cur] = num</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> numList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numList = [randint(-<span class="number">100</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;桶排序前：&quot;</span>, numList)</span><br><span class="line">    numList = bucketSort(numList)   <span class="comment"># 桶排序</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;桶排序后：&quot;</span>, numList)</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">桶排序前： [54, 62, 82, 96, -61, -82, -15, -55, 35, -49]</span><br><span class="line">桶排序后： [-82, -61, -55, -49, -15, 35, 54, 62, 82, 96]</span><br></pre></td></tr></table></figure><hr/><h1>写在最后</h1><blockquote><ul><li>如果您发现文章存在问题，或者如果您有更好的建议，欢迎在下方评论区中留言讨论~</li><li>本文参考文章：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html">【JavaScript】十大经典排序算法（动图演示排序过程）</a></li><li>推荐一个算法可视化网站：<a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html">旧金山大学算法可视化平台</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法分析 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
